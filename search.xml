<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mac开发环境搭建-v2]]></title>
    <url>%2F2018%2FMac%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-v2%2F</url>
    <content type="text"><![CDATA[序言电脑不幸中招 键盘事件，已经换了一台了，苹果这质量是每况愈下啊，哎哎哎。这是第二次重装软件了，所以积累了不少经验。将会从以下方面进行介绍，所有的软件安装，请按照顺序来操作，有些是有依赖关系的。 系统设置 常用软件 Node开发配置 Java开发配置 系统设置开启Mac三指拖拽的手势使用三指拖动文件、窗口等，非常好用的功能，macOS系统中默认关闭了这个功能，参考百度经验的设置方法：点击跳转 常用软件安装 Oh My ZSH为什么装这个以及主题设置，网上搜索教程吧，一大把，官方地址：https://ohmyz.sh。 1sh -c "$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)" 安装 homebrew 包管理有了这个包管理工具之后，以后安装软件会非常方便，谁用谁知道。官方地址：http://brew.sh，使用下面的命令进行安装，耐心等待一会儿就安装好了。 1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 使用brew安装软件，测试安装是否成功 12345678$ brew install wgetUpdating Homebrew...$ wgetwget: missing URLUsage: wget [OPTION]... [URL]...Try `wget --help' for more options. 安装 iTerm2 终端比系统自带的“终端命令”更好用的软件 1brew cask install iterm2 当你已经把 zsh、homebrew和 iTerm2 这三剑客安装完毕，是时候关闭 系统自带的终端，打开刚才安装完成的 iTerm2 骚起来吧。 使用 expect 实现 SSH 自动登陆查看你的系统是否有 expect 命令，如果没有就先安装一下 1234$ expect -versionexpect version 5.45 # 说明已经安装过了，就不需要再安装了$$ brew install expect expect 登陆脚本如下，找个目录保存下文件 1vim ~/.ssh/iterm2login.sh 123456789101112#!/usr/bin/expect -fset port 22set host [lindex $argv 0]set user [lindex $argv 1]set password [lindex $argv 2]set timeout -1spawn ssh -o "StrictHostKeyChecking no" -o ServerAliveInterval=10 -p$port $user@$hostexpect "*assword:*"send "$password\r"interactexpect eof 1chmod +x ~/.ssh/iterm2login.sh 12$ # iterm2login.sh 主机地址 端口号 用户 密码$ sh iterm2login.sh 10.11.0.2 22 admin paswword iTerm2 打开菜单 Profiles -&gt; Open Profiles... -&gt; Edit Profiles... 安装 Alfredalfred 上手教程 1234http://www.jianshu.com/p/e9f3352c785fhttps://sspai.com/post/32979http://www.jianshu.com/p/0e78168da7abhttps://sspai.com/post/32680 安装七牛云图床工具用于博客图床上传工具 七牛云workflow地址：https://github.com/onestark/alfred-workflow-qshell 七牛云qshell地址：https://developer.qiniu.com/kodo/tools/1302/qshell 123456$ wget http://devtools.qiniu.com/qshell-v2.1.8.zip$ unzip qshell-v2.1.8.zip$ cd qshell-v2.1.8$ mv qshell-darwin-x64 /usr/local/bin/qshell$ # 安装完成之后，新打开一个命令窗口$ qshell account [七牛账户下的AccessKey] [七牛账户下的SecretKey] # 密钥设置 安装 1Password日常密码管理工具 安装 SizeUp日常窗口管理工具 安装 Snipaste 截图工具日常截图工具，替换系统自带的截图，功能强大，不依赖 qq、微信 的截图，官网地址：https://zh.snipaste.com 1brew cask install snipaste 安装 BetterTouchTool强大的手势自定义工具，上手教程，参考网友的介绍文章 1https://www.jianshu.com/p/ba8d766559ca 个人日常使用最多的功能，就是使用 三指选中文本内容进行搜索，我是这么配置的，设置中打开 Trackpads，安装下面的 2 个步骤，新增多个同样的手势 12&quot;Touchpad Gesture&quot; 设置为 &quot;3 Finger Click&quot; 手势&quot;Predefined Action&quot; 设置为 &quot;Open URL/Open URL With Selection&quot;，填入你想要使用的搜索引擎地址 安装 HyperDock扩展 Dock 拦功能，安装完成之后，需要注销/重启系统。将鼠标放在 Dock 拦的应用程序上面，就可以进行快速预览，并且能通过数字键 1~9 进行快速移动到对应的桌面中，非常的方便 安装图形软件罗列一些常用的软件 123456$ brew cask install google-chrome # 安装 Google 浏览器$ brew cask install shadowsocksx-ng # 科学上网客户端$ brew cask install aria2gui # aria2下载软件客户端$ brew cask install mysqlworkbench # mysql workbench$ brew cask install sourcetree # git免费的客户端$ brew cask install postman # http请求测试客户端 安装快速浏览插件，都是使用“空格键”快速查看文件 12345$ brew cask install qlstephen # 快速查看纯文本文件$ brew cask install qlcolorcode # 在预览源代码文件，高亮代码$ brew cask install qlmarkdown # 预览 Markdown 文件$ brew cask install quicklook-json # 预览 JSON 文件$ brew cask install quicklook-csv # 预览 CSV 文件 Node开发推荐使用 n 管理 node 版本不会遇到 安装nvm之后 导致终端启动慢的问题 https://github.com/tj/n 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758$ brew install n==&gt; Downloading https://homebrew.bintray.com/bottles/n-6.1.3.catalina.bottle.tar.gz######################################################################## 100.0%==&gt; Pouring n-6.1.3.catalina.bottle.tar.gz🍺 /usr/local/Cellar/n/6.1.3: 6 files, 52.8KB$ n lsfind: /usr/local/n/versions: No such file or directory$ n ls-remoteListing remote... Displaying 20 matches (use --all to see all).13.3.013.2.013.1.013.0.113.0.012.13.112.13.012.12.012.11.112.11.012.10.012.9.112.9.012.8.112.8.012.7.012.6.012.5.012.4.012.3.1$ n lsfind: /usr/local/n/versions: No such file or directory$ n 8.10 installing : node-v8.10.0 mkdir : /usr/local/n/versions/node/8.10.0mkdir: /usr/local/n/versions/node/8.10.0: Permission denied Error: sudo required (or change ownership, or define N_PREFIX)$ which n/usr/local/bin/n$ mkdir /usr/local/nmkdir: /usr/local/n: Permission denied$ sudo mkdir /usr/local/n$ sudo chown -R $(whoami) /usr/local/n$ n 8.10 installing : node-v8.10.0 mkdir : /usr/local/n/versions/node/8.10.0 fetch : https://nodejs.org/dist/v8.10.0/node-v8.10.0-darwin-x64.tar.gz installed : v8.10.0 (with npm 5.6.0)$ n lsnode/8.10.0$ node -vv8.10.0$ npm -v5.6.0 使用 nvm 管理 node 版本下载源代码到 zsh 插件目录。为什么要用这种方式？你有没有遇到过安装完nvm之后就遇到了终端启动慢的问题，要等2～3秒钟的时间，就是因为$NVM_DIR/nvm.sh 导致的，网友遇到到同样的问题，请移步查看。 1git clone git@github.com:lukechilds/zsh-nvm.git ~/.oh-my-zsh/custom/plugins/zsh-nvm 在 vim ~/.zshrc 中启用 zsh-nvm 插件 123plugins=( zsh-nvm) 在 vim ~/.zshrc 首行中启用 nvm 的延时加载，加快终端打开的速度 1export NVM_LAZY_LOAD=true nvm 使用方法 123456$ nvm ls-remote #查看官网 node 的所有版本$ nvm install 8.10.0 #指定 node 的版本号进行安装$ nvm ls #查看已经安装的 node 版本$ nvm use xxx #使用指定版本的 node$ node -v$ npm -v npm 常用命令12345678$ npm list -g --depth 0 #查看全局安装过的包命令/Users/jerry/.nvm/versions/node/v8.10.0/lib├── anywhere@1.5.0├── hexo-cli@1.1.0├── npm@5.6.0├── npm-check-updates@2.14.2└── nrm@1.0.2$ npm 常用插件列举一些日常必备、使用较多的插件 123$ npm install -g nrm # 管理 npm registry$ npm install -g anywhere # 在任意目录就能启动一个文件浏览服务$ npm install -g npm-check-updates #使用 ncu -u 更新 package.json 文件并，并保存新的版本号 安装 VS Code微软出品的图形开发工具，官方网站：https://code.visualstudio.com/ 1brew cask install visual-studio-code Java 开发安装 Java SDK通过 brew 安装多个版本的 Java SDK，下面命令演示安装 Java 8 1brew cask install java8 如果需要安装JDK 6/7，可以通过homebrew-cask-versions 12345678910111213141516171819202122232425$ brew tap homebrew/cask-versions## 这个可以考虑不安装==&gt; Tapping homebrew/cask-versionsCloning into '/usr/local/Homebrew/Library/Taps/homebrew/homebrew-cask-versions'...remote: Enumerating objects: 190, done.remote: Counting objects: 100% (190/190), done.remote: Compressing objects: 100% (187/187), done.remote: Total 190 (delta 13), reused 38 (delta 0), pack-reused 0Receiving objects: 100% (190/190), 82.60 KiB | 209.00 KiB/s, done.Resolving deltas: 100% (13/13), done.Tapped 159 casks (207 files, 322.2KB).$ brew tap AdoptOpenJDK/openjdk## 使用 OpenJDK==&gt; Tapping adoptopenjdk/openjdkCloning into '/usr/local/Homebrew/Library/Taps/adoptopenjdk/homebrew-openjdk'...remote: Enumerating objects: 40, done.remote: Counting objects: 100% (40/40), done.remote: Compressing objects: 100% (37/37), done.remote: Total 40 (delta 23), reused 6 (delta 0), pack-reused 0Unpacking objects: 100% (40/40), done.Tapped 26 casks (98 files, 100.6KB).$ brew cask install adoptopenjdk8 # 这个可能会执行失败，因为在多个 tap 组里，那就执行下面这个吧$ brew cask install adoptopenjdk/openjdk/adoptopenjdk8 搜索其它版本的 Java SDK 12345678910$ brew search openjdk==&gt; Formulaeopenjdk openjdk@11 openjdk@12==&gt; Casksadoptopenjdk adoptopenjdk11-openj9-jre adoptopenjdk12-openj9 adoptopenjdk13-jre adoptopenjdk8 adoptopenjdk8-openj9-jre-largeadoptopenjdk10 adoptopenjdk11-openj9-jre-large adoptopenjdk12-openj9-jre adoptopenjdk13-openj9 adoptopenjdk8 adoptopenjdk8-openj9-largeadoptopenjdk11 adoptopenjdk11-openj9-large adoptopenjdk12-openj9-jre-large adoptopenjdk13-openj9-jre adoptopenjdk8-jre adoptopenjdk9adoptopenjdk11-jre adoptopenjdk12 adoptopenjdk12-openj9-large adoptopenjdk13-openj9-jre-large adoptopenjdk8-openj9adoptopenjdk11-openj9 adoptopenjdk12-jre adoptopenjdk13 adoptopenjdk13-openj9-large adoptopenjdk8-openj9-jre 查看系统安装中安装的所有JDK 1234567891011$ /usr/libexec/java_home -VMatching Java Virtual Machines (4): 1.8.0_121, x86_64: "Java SE 8" /Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home 1.7.0_80, x86_64: "Java SE 7" /Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home 1.6.0_65-b14-468, x86_64: "Java SE 6" /Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home 1.6.0_65-b14-468, i386: "Java SE 6" /Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home/Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home$ /usr/libexec/java_home -v 1.6/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home 使用jEnv管理多个Java SDK版本jEnv帮助我们更简单的管理多个JDK：http://www.jenv.be/ 1$ brew install jenv bash中做以下配置，并记得重启终端/重新打开新的选项卡 12$ echo 'export PATH="$HOME/.jenv/bin:$PATH"' &gt;&gt; ~/.bash_profile$ echo 'eval "$(jenv init -)"' &gt;&gt; ~/.bash_profile Zsh中做以下配置，并记得重启终端/重新打开新的选项卡 12$ echo 'export PATH="$HOME/.jenv/bin:$PATH"' &gt;&gt; ~/.zshrc$ echo 'eval "$(jenv init -)"' &gt;&gt; ~/.zshrc # 不配置好像没有关系 jEnv不能自己安装任何版本的JDK，所以需要我们手动安装好之后再用jEnv add xxx指向它们。第一次添加的时候如果出现下面的错误，后来在 jenv github wiki 中找到解决方案，如果没有出现就忽略。 12345678910111213141516171819$ jenv add /Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Homeln: /Users/jerry/.jenv/versions/oracle64-1.6.0.65: No such file or directory#解决方案1： 修改 ~/.bash_profile，增加下面的内容$ vi ~/.bash_profile# To enable shims and autocompletion add to your profile:if which jenv &gt; /dev/null; then eval "$(jenv init -)"; fi# To use Homebrew's directories rather than ~/.jenv add to your profile:export JENV_ROOT=/usr/local/opt/jenv# 解决方案2:$ jenv add /Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Homeln: /Users/jerry/.jenv/versions/openjdk64-1.8.0.232: No such file or directory$ mkdir -p .jenv/versions$ jenv add /Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Homeopenjdk64-1.8.0.232 added1.8.0.232 added1.8 added 添加JDK 123$ jenv add /Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home/$ jenv add /Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents//Home/$ jenv add /Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/ 查看所有JDK 1234567891011$ jenv versions* system (set by /usr/local/opt/jenv/version) 1.6 1.6.0.65 1.7 1.7.0.80 1.8 1.8.0.121 oracle64-1.6.0.65 oracle64-1.7.0.80 oracle64-1.8.0.121 设置全局JDK 1$ jenv global 1.8 设置文件夹的JDK，设置的信息保存在.java-version文件中 1234$ jenv local 1.6$ cat .java-version1.6$ rm -rf .java-version 设置shell的JDK，似乎只在当前shell窗口生效 1$ jenv shell 1.7 其它用法 12$ jenv which java/usr/local/opt/jenv/versions/1.7/bin/java 安装Maven官方网址：https://maven.apache.org 1$ brew install maven maven的java版本随jenv切换改变而改变，参考 jenv issue 12$ vi ~/.mavenrcJAVA_HOME=$(/usr/libexec/java_home -v $(jenv version-name)) 安装IntelliJ Idea官方网站：https://www.jetbrains.com/idea/。从 2018.2 版本已经支持 MacBook Pro 的 Touch Bar了，感觉不错。]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>开发配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac开发环境搭建-v1]]></title>
    <url>%2F2017%2FMac%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-v1%2F</url>
    <content type="text"><![CDATA[前言，不知从何时开始向往能在Mac下开发，如今终于实现，感谢老婆大人的支持。废话不多，开始记录从零开始搭建开发环境，主要是Java、node的配置 开启Mac三指拖拽的手势非常好用的功能，macOS系统中默认关闭了这个功能，参考百度经验的设置方法：点击跳转 科学上网天朝的程序员此处伤害一万点，都是血泪史啊。 安装shadowsocks，参考wiki地址方法：https://github.com/shadowsocks/shadowsocks/wiki，安装完成之后使用ss账户进行登陆，能打开Google即可，完成第一步。 安装chrome和SwitchyOmega插件，按照插件的配置方法，设置浏览器的动态代理。 安装 homebrew有了这个包管理工具之后，以后安装软件会非常方便，谁用谁知道。参考官方地址方法进行安装：http://brew.sh/，耐心等待一会儿就安装好了。 使用brew安装软件，测试安装是否成功 12345678$ brew install wgetUpdating Homebrew...$ wgetwget: missing URLUsage: wget [OPTION]... [URL]...Try `wget --help' for more options. 你已经感受到了使用 Homebrew 安装命令行程序的便利。那么接下来，我们将通过 Homebrew Cask 优雅、简单、快速的安装和管理 OS X 图形界面程序，比如 Google Chrome 和 Dropbox。https://caskroom.github.io/ 123$ brew install caskroom/cask/brew-cask$ brew cask install google-chrome // 安装 Google 浏览器$ brew update &amp;&amp; brew upgrade brew-cask &amp;&amp; brew cleanup // 更新 brew是从下载源码解压然后./configure &amp;&amp; make install，同时会包含相关依存库。并自动配置好各种环境变量，而且易于卸载。这个对程员来说简直是福音，简单的指令，就能快速安装和升级本地的各种开发环境。 brew cask是将已经编译好了的应用包（.dmg/.pkg），仅仅是下载解压，省掉了自己去下载、解压、拖拽（安装）等蛋疼步骤，同样，卸载相当容易与干净。这个对一般用户来说会比较方便，包含很多在 AppStore 里没有的常用软件。 通过NVM安装不同版本的node众所周知，node版本更新是非常的频繁，如果是全局安装，之后需要临时切换或者升级，是非常不方便多。通过nvm非常方便的来管理node的不同版本，跟上节奏嗨起来。 通过brew安装nvm 12$ brew install nvm$ mkdir ~/.nvm 修改~/.bash_profile文件，追加以下内容 123# 使用 brew install nvm，需要做以下配置export NVM_DIR="$HOME/.nvm"source $(brew --prefix nvm)/nvm.sh 使刚才的修改生效 1$ source ~/.bash_profile 安装node 12345$ nvm ls-remote #查看官网node的所有版本$ nvm install 7.5.0 #指定node的版本号进行安装$ nvm use xxx #使用指定版本的node $ node -v$ npm -v 安装Atom前端开发工具1$ brew cask install atom 安装插件 12345678910111213activate-power-modeatom-clockcolor-pickereditorconfigemmetfile-iconsgit-pluslinterlinter-eslintlinter-stylelintminimapplatformio-ide-terminalreact 安装Java SDK通过brew安装JDK 8 1$ brew cask install java 如果需要安装JDK 6/7，可以通过homebrew-cask-versions 123$ brew tap caskroom/versions$ brew cask install java6$ brew cask install java7 查看系统安装中安装的所有JDK 1234567891011$ /usr/libexec/java_home -VMatching Java Virtual Machines (4): 1.8.0_121, x86_64: "Java SE 8" /Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home 1.7.0_80, x86_64: "Java SE 7" /Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home 1.6.0_65-b14-468, x86_64: "Java SE 6" /Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home 1.6.0_65-b14-468, i386: "Java SE 6" /Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home/Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home$ /usr/libexec/java_home -v 1.6/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home 使用jEnv管理多个Java SDK版本jEnv帮助我们更简单的管理多个JDK：http://www.jenv.be/ 1$ brew install jenv bash中做以下配置 12$ echo 'export PATH="$HOME/.jenv/bin:$PATH"' &gt;&gt; ~/.bash_profile$ echo 'eval "$(jenv init -)"' &gt;&gt; ~/.bash_profile Zsh中做以下配置 12$ echo 'export PATH="$HOME/.jenv/bin:$PATH"' &gt;&gt; ~/.zshrc$ echo 'eval "$(jenv init -)"' &gt;&gt; ~/.zshrc jEnv不能自己安装任何版本的JDK，所以需要我们手动安装好之后再用jEnv add xxx指向它们。第一次添加的时候出现下面的错误，后来在 jenv github wiki 中找到解决方案，如果没有出现就忽略。 12345678910$ jenv add /Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Homeln: /Users/jerry/.jenv/versions/oracle64-1.6.0.65: No such file or directory#解决方案，修改 ~/.bash_profile，增加下面的内容$ vi ~/.bash_profile# To enable shims and autocompletion add to your profile:if which jenv &gt; /dev/null; then eval "$(jenv init -)"; fi# To use Homebrew's directories rather than ~/.jenv add to your profile:export JENV_ROOT=/usr/local/opt/jenv 添加JDK 123$ jenv add /Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home/$ jenv add /Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents//Home/$ jenv add /Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/ 查看所有JDK 1234567891011$ jenv versions* system (set by /usr/local/opt/jenv/version) 1.6 1.6.0.65 1.7 1.7.0.80 1.8 1.8.0.121 oracle64-1.6.0.65 oracle64-1.7.0.80 oracle64-1.8.0.121 设置全局JDK 1$ jenv global 1.8 设置文件夹的JDK，设置的信息保存在.java-version文件中 1234$ jenv local 1.6$ cat .java-version1.6$ rm -rf .java-version 设置shell的JDK，似乎只在当前shell窗口生效 1$ jenv shell 1.7 其它用法 12$ jenv which java/usr/local/opt/jenv/versions/1.7/bin/java 安装Mavenhttps://maven.apache.org 1$ brew install maven maven的java版本随jenv切换改变而改变，参考 jenv issue 12$ vi ~/.mavenrcJAVA_HOME=$(/usr/libexec/java_home -v $(jenv version-name)) 安装iTerm2https://www.iterm2.com/ 1$ brew cask install iterm2 安装go2shellhttp://zipzapmac.com/go2shell这个软件能够让你在Finder中轻松地在当前路径打开shell 1$ brew cask install go2shell 安装完成之后，在应用程序中打开go2shell，然后点击Thank The Developers，会打开一个donate的网页，你可以选择捐钱或者复制DONATE_BY_FOLLOW填入go2shell的文本框中，回车即可。 1Not Ready to Donate? Just follow us on twitter and enter DONATE_BY_FOLLOW in Go2Shell code field! Codes for other donation options will be available after checkout. 完成上面步骤之后，在Finder的工具拦中会多一个go2shell的图标，点击它就能打开shell终端程序了。 安装KeepingYouAwakehttps://github.com/newmarcel/KeepingYouAwake保持Mac不休眠的软件，方便PPT等演示的时候不出现尴尬的画面。 1$ brew cask install keepingyouawake 安装MacDown编辑器http://macdown.uranusjr.com/免费开源的MarkDown编辑器 1$ brew cask install macdown 安装IntelliJ Ideahttps://www.jetbrains.com/idea/下载配置文件：https://github.com/myoss/IntelliJIdea-Config-MacOS 12345$ cd /Users/jerry/Library/Preferences/IntelliJIdea2016.3$ git clone git@github.com:myoss/IntelliJIdea-Config-MacOS.git .$ vi fileTemplates/includes/File\ Header.java# 将 ` * @author $&#123;USER&#125; $fdate` 中的 `$&#123;USER&#125;` 替换为你需要的名字，默认是电脑的账户名 安装git gui工具SourceTreehttps://www.sourcetreeapp.com/ 目前是免费的工具，需要注册一下他们家的账户才能使用。 安装dos2unix命令转化文件的换行符Windows和Linux中文件的换行符的不同，导致文件见的一些“不兼容”问题，通过unix2dos 和dos2unix来实现互相转换。为了解决git add的时候的错误fatal: CRLF would be replaced by LF，或者用来将文件中的CRLF转换为LF。http://linuxcommand.org/man_pages/dos2unix1.html 1$ brew install dos2unix -k 保持文件时间戳不变-n 新文件模式，待修改的源文件重定向到新的文件中-o 旧文件模式，将修改后的内容保存在源文件中，默认就是此模式 123$ dos2unix -k -n source.sql target.sql #将替换后的文件保存在target.sql中，不改变source.sql原始文件$ dos2unix -k source.sql #替换文件$ find . -name *.sql | xargs dos2unix -k #批量替换文件 unix2dos UNIX(LF) -&gt; DOS(CRLF)dos2unix DOS(CRLF) -&gt; UNIX(LF)mac2unix MAC(R) -&gt; UNIX(LF) 使用cat命令查看不可见的字符：http://os.51cto.com/art/201310/413568.htm 123456789101112131415$ cat -T test.txt #用cat -T命令来显示TAB键的字符^Itesting ^I^Itesting more testing ^I $ cat -E /tmp/test.txt #用cat -E命令来显示行尾的结束字符$testing$ testing $ $ cat -A /tmp/testing.txt #用cat -A命令就可以显示所有不可见的字符testing$ ^I^Itesting^L^H$]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>开发配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim编辑器用法]]></title>
    <url>%2F2016%2Fvim%E7%BC%96%E8%BE%91%E5%99%A8%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[vim编辑器使用笔记 vim快捷操作一览（网友制作） vim编辑器操作模式vim编辑器提供了三种操作模式 命令行模式（Command）进入vim编辑器后的默认模式就是命令行模式，在其它两个模式中，按Ecs/Escape键回到命令行模式 文本输入模式（Input）在命令行模式中，按i、o、a键进入文本输入模式 末行模式（Last Line）在命令行模式中，按:键进入末行模式，输入命令完成之后按Enter键触发相应的动作 在vim编辑器中进行移动光标操作 按键 描述（大写的字母，可以用Shift+字母，也可以是大写模式下的字母） h 或 方向键← 或 Backspace 向左移动一个字符 j 或 方向键↓ 向下移动一行 l 或 方向键→ 向右移动一个字符 k 或 方向键↑ 向上移动一行 w 或 W 移动到当前或者下一个单词的词首 b 或 B 移动到当前或者上一个单词的词首 e 或 E 移动到当前或者下一个单词的词尾 $ 移动到当前行末尾 ^ 移动到当前行开头第一个非空格字符 0（数字0） 移动到当前行行首 n + 丨 移动到当前行的第n个字符，从行首开始记数 H 移动到屏幕顶端第一个非空格字符 M 移动到屏幕中间第一个非空格字符 L 移动到屏幕底部第一个非空格字符 Enter（回车键） 移动到下一行行首 G 移动到文件的最后一行 1G 或 gg 移动到文件的第一行 nG 移动到第n行，先输入数字，再输入G :n 移动到第n行 Ctrl + F 向下滚动一屏 Ctrl + D 向下滚动半屏（down） Ctrl + B 向上滚动一屏 Ctrl + U 向上滚动半屏（up） Ctrl + G 显示当前文件缓冲信息（如：文件名、文件数、光标所在行在总行数中所处的百分比位置等） 使用vim编辑器进行文本修改输入文本命令 按键 描述 a 在光标位置后进行输入文本（append） A 在当前行末尾进行输入文本（append） i 在光标位置前进行输入文本（insert） I 在当前行行首进行输入文本（insert） o 在光标下新插入一行进行输入文本（open） O 在光标上新插入一行进行输入文本（open） 删除文本命令 按键 描述 x（小写） 删除光标所在的字符（删除单个字符） X 删除光标前的字符（删除单个字符） dw 删除一个单词，不适用中文 dd 删除光标所在的行 D 或者 d$ 删除光标到行末尾的字符（包含光标所在字符） d0 或者 d^ 删除光标前一个字符到行首的字符（不包含光标所在字符） dG 删除当前行到文件的最后一行之间的内容 d1G 或者 dgg 删除当前行到文件的第一行之间的内容 :m,nd 删除第m行到第n行的内容（例如： 4,9d，即删除4~9行） 替换文本命令 按键 描述 :r filename 将读取filename文件中的内容插入到当前文件夹光标所在位置（filename可以使用目录+文件名，用Tab键补全，确认后就按Enter） R 覆盖式替换光标所在的字符。先按R，然后输入字符，替换当前光标所在的字符，替换后会移动到下一个字符，按ESC键退出替换模式 S 插入式替换光标所在的字符，按S之后，先会删除当前字符，继续输入字符，进行插入字符操作，而不是像R进行后续字符的替换动作 cc 或者 S 用空白替换当前行的内容（直接删除当前行的内容，使之成为空行） c$ 或者 C 用空白替换当前行光标到行尾的字符 c^ 或者 c0 用空白替换当前行光标前一个字符到行首的字符（不包含光标所在字符） ~ 光标所在字母进行大小写转换，转换之后移动到下一个字符 回退操作命令 按键 描述 u 回退之前执行的命令，多次操作则执行多次回退操作 U 回退对于当前行所执行的命令，多次操作则执行多次回退操作 重复执行命令 按键 描述 . 重复执行上一个命令 n + 命令 数字 + 命令，重复执行某动作 5dd 删除5行，从当前行开始 3r 按了3r之后，输入一个字符，则从光标处开始的3个字符都会被输入的字符给替换掉 5J 将5行合并成一行，从当前行开始 3x 删除3个字符 5i + 任意或者多个字符 输入5ihelllo按Esc，将插入5遍hello 3G 移动到第3行 5l（小写的L） 将光标向右移动5个字符，其它方向键类似 5k（小写的K） 将光标向上移动5行，其它方向键类似 使用vim编辑器查找和替换文本查找命令 按键 描述 /string 从光标位置开始向下]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis 简单配置和集群]]></title>
    <url>%2F2016%2Fredis-%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%E5%92%8C%E9%9B%86%E7%BE%A4%2F</url>
    <content type="text"><![CDATA[下载和编译redis官网：http://redis.io/redis中文：http://www.redis.cn/redis快速上手：http://redis.io/topics/quickstart 下载，解压，编译1234[root@linux1 Downloads]# wget http://download.redis.io/releases/redis-3.0.7.tar.gz[root@linux1 Downloads]# tar zxf redis-3.0.7.tar.gz[root@linux1 Downloads]# cd redis-3.0.7[root@linux1 Downloads]# make 编译完成之后会在./src目录中生成4个文件 redis-server Redis服务器的daemon启动程序redis-cli Redis命令行操作工具。当然，你也可以用telnet根据其纯文本协议来操作redis-benchmark Redis性能测试工具，测试Redis在你的系统及你的配置下的读写性能redis-stat Redis状态检测工具，可以检测Redis当前状态参数及延迟状况 初次运行二进制文件是编译完成后在src目录下。默认端口是6379，运行如下: 1[root@linux1 redis-3.0.7]# src/redis-server redis默认运行不是静默的方式，使用ctrl + c停止redis服务 指定配置文件启动redis 1[root@linux1 src]# ./redis-server ../redis.conf 自带的客户端连接redis服务 12[root@linux1 src]# ./redis-cli127.0.0.1:6379&gt; 停止redis服务 1234567$ ./redis-cli shutdown$ ./redis-cli -p 6380 shutdown #关闭指定端口的redis服务$ pkill redis$ ps -ef | grep redis$ kill -9 pid install方式安装编译安装12345[root@linux2 redis-3.0.7]# mkdir /usr/local/redis[root@linux2 redis-3.0.7]# make[root@linux2 redis-3.0.7]# make PREFIX=/usr/local/redis install[root@linux2 redis-3.0.7]# ls /usr/local/redisbin 性能测试使用redis-benchmark测试12345678910111213141516171819202122232425262728293031[root@linux2 bin]# ./redis-benchmark -t GET,SET====== SET ====== 100000 requests completed in 1.68 seconds 50 parallel clients 3 bytes payload keep alive: 194.12% &lt;= 1 milliseconds99.62% &lt;= 2 milliseconds99.90% &lt;= 3 milliseconds99.92% &lt;= 4 milliseconds99.95% &lt;= 9 milliseconds100.00% &lt;= 9 milliseconds59417.71 requests per second====== GET ====== 100000 requests completed in 1.44 seconds 50 parallel clients 3 bytes payload keep alive: 198.93% &lt;= 1 milliseconds99.91% &lt;= 2 milliseconds99.95% &lt;= 3 milliseconds99.97% &lt;= 5 milliseconds100.00% &lt;= 5 milliseconds69300.07 requests per second[root@linux2 bin]# ./redis-benchmark -t GET,SET -q # 精简输出SET: 70422.54 requests per secondGET: 69735.01 requests per second redis服务集群配置使用单机的方式演示集群，多机器类似 创建两个文件夹用于分别部署master和slave 1234[root@linux1 redis-3.0.7]# mkdir -p /usr/local/redis/bin[root@linux1 redis-3.0.7]# mkdir -p /usr/local/redis/run[root@linux1 redis-3.0.7]# mkdir -p /usr/local/redis1/bin[root@linux1 redis-3.0.7]# mkdir -p /usr/local/redis1/run 复制编译好的文件将刚才编译好的二进制文件和配置文件，分别复制到刚才创建好的文件夹中 123456[root@linux1 redis-3.0.7]# cd src/[root@linux1 src]# cp mkreleasehdr.sh redis-benchmark redis-check-aof redis-check-dump redis-cli redis-server /usr/local/redis/bin[root@linux1 src]# cp mkreleasehdr.sh redis-benchmark redis-check-aof redis-check-dump redis-cli redis-server /usr/local/redis1/bin[root@linux1 src]# cp ../redis.conf /usr/local/redis/bin[root@linux1 src]# cp ../redis.conf /usr/local/redis1/bin 配置master123456789[root@linux1 ~]# cd /usr/local/redis/bin[root@linux1 bin]# vi redis.conf daemonize no设置为后台运行：daemonize yespidfile /var/run/redis.pid修改pid文件的位置，设置为：pidfile /usr/local/redis/run/redis.pid 配置slave123456789101112131415161718192021[root@linux1 ~]# cd /usr/local/redis1/bin[root@linux1 bin]# vi redis.conf daemonize no设置为后台运行：daemonize yesport 6379将端口号6379修改为：port 6380pidfile /var/run/redis.pid修改pid文件的位置，设置为：pidfile /usr/local/redis1/run/redis.pid# slaveof &lt;masterip&gt; &lt;masterport&gt;设置master机器的ip和端口号，设置为：slaveof 127.0.0.1 6379# masterauth &lt;master-password&gt;如果master主机设置了密码，设置为：masterauth &lt;master-password&gt; 启动集群分别启动master和slave服务 12[root@linux1 bin]# ./redis-server redis.conf[root@linux1 bin]# ./redis-server redis.conf 查看master服务的信息 123456789101112[root@linux1 bin]# ./redis-cli127.0.0.1:6379&gt; info# Replication #查看此节点的信息role:master #当前服务的角色是masterconnected_slaves:1 #现在有一台`slave`的机器，下面显示的是IP和端口和状态信息slave0:ip=127.0.0.1,port=6380,state=online,offset=71,lag=1master_repl_offset:71repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:2repl_backlog_histlen:70 查看slave服务的信息 12345678910111213141516171819[root@linux1 bin]# ./redis-cli -p 6380127.0.0.1:6380&gt; info# Replicationrole:slave #当前服务的角色是slavemaster_host:127.0.0.1 #master机器的IPmaster_port:6379 #master机器的端口master_link_status:upmaster_last_io_seconds_ago:1master_sync_in_progress:0slave_repl_offset:323slave_priority:100slave_read_only:1connected_slaves:0master_repl_offset:0repl_backlog_active:0repl_backlog_size:1048576repl_backlog_first_byte_offset:0repl_backlog_histlen:0 测试master和slave现在都没有数据 12345127.0.0.1:6379&gt; keys *(empty list or set)127.0.0.1:6380&gt; keys *(empty list or set) 往master服务中写入数据 123456127.0.0.1:6379&gt; set name Jerry.ChenOK127.0.0.1:6379&gt; keys *1) "name"127.0.0.1:6379&gt; get name"Jerry.Chen" slave服务中查看数据 1234127.0.0.1:6380&gt; keys *1) "name"127.0.0.1:6380&gt; get name"Jerry.Chen" redis.conf 配置文件12[root@linux1 ~]# cd /usr/local/redis/bin[root@linux1 bin]# vi redis.conf daemonize是否后台运行，默认是no，修改为yes，即可以在后台运行了 requirepass设置redis服务的密码，默认未开启，查找# requirepass foobared，然后修改进行开启密码。如果开启了密码，命令行操作方式 12[root@linux1 bin]# ./redis-server -a foobared127.0.0.1:6379&gt; auth foobared pidfileredis服务的pid文件位置 timeout请求超时时间 loglevellog信息级别 logfilelog文件位置 databases开启数据库的数量，默认是16个 save 保存快照的频率，第一个表示多长时间，第三个表示执行多少次写操作。在一定时间内执行一定数量的写操作时，自动保存快照。可设置多个条件。 appendonly默认是no，可以写yes。这个选项就是负责是否开启AOF日志的开关。AOF日志，你可以简单理解为MySQL binlog一样的东西，作用就是记录每次的写操作，在遇到断电等问题时可以用它来恢复数据库状态。但是他不是二进制的，而是文本的，一行一行，写得很规范。如果你是一台redis，那你也能人肉通过它恢复数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364############################## 仅追加方式 ################################默认情况下Redis会异步的将数据导出到磁盘上。这种模式对许多应用程序已经足够了，#但是如果断电或者redis进程出问题就会导致一段时间内的更新数据丢失（取决与配置项）##这种只增文件是可选的能够提供更好的体验的数据持久化策略。#举个例子，如果使用默认的配置数据fsync策略，在服务器意外断电的情况下redis只会丢失一秒中内的更新数据，#或者当redis进程出问题但操作系统运转正常时，redis只会丢失一个数据更新操作。##AOF 和 RDB 持久化方式可以同时启动并且无冲突。#如果AOF开启，启动redis时会加载aof文件，这些文件能够提供更好的保证。#请在 http://redis.io/topics/persistence 获取更多数据持久化信息。appendonly no# 只增文件的文件名称。（默认是appendonly.aof）# appendfilename appendonly.aof#调用fsync()函数会通知操作系统真正将数据写入磁盘，而不是等待缓冲区中有更多数据。#有些操作系统会将数据输出到磁盘，有些操作系统只是ASAP。##redis支持三种不同的方式：##no:不调用，之等待操作系统来清空缓冲区当操作系统要输出数据时。很快。# always: 每次更新数据都写入仅增日志文件。慢，但是最安全。# everysec: 每秒调用一次。折中。##默认是每秒中一次，因为它往往是在速度和数据安全两者之间的折中选择。#如果你可以接受让操作系统去自动清空缓存，你可以将这项配置降低到'no'(如果你可以接受一段时间的数据丢失，默认的rdb就足够了)，#这完全取决与你。如果你想要一个更好的体验或者从相反的角度，使用'always'，这样会很慢，但是比'everysec'安全些。##请在下面的文章中获取更多细节知识：# http://antirez.com/post/redis-persistence-demystified.html##如果你不是很清楚这三项之间的区别，或者不知道哪种适合你的机器，就是用默认吧。# appendfsync alwaysappendfsync everysec# appendfsync no#当AOF策略设置为'always'或者'everysec'的时候，后台的保存进程会进行很多磁盘I／O操作，#在某些linux结构中redis会在调用sync()方法时阻塞很长时间。记住，现在还没办法解决这个问题，即使在不同进程中进行调用也会block。##使用如下配置可能会缓解这个问题，这样会在存储大数据或者BIGREWRITEAOF的时候不会在主进程中调用fsync()方法。## 这表示，如果另外一个子进程在进行保存操作，redis的表现如同配置为‘appendfsync no’。#在实际应用中，这表示在最坏的情景下（使用linux默认配置）可能会丢失30秒日志。# #如果你有特殊的情况可以配置为'yes'。但是配置为'no'是最为安全的选择。no-appendfsync-on-rewrite no#自动重写只增文件。#redis可以自动盲从的调用‘BGREWRITEAOF’来重写日志文件，如果日志文件增长了指定的百分比。# #它是这样工作的：每次rewrite后redis会记录日志文件的大小。（如果重启后没有重写后的大小，就默认用日志文件大小）## 这个基准日志大小和当前日志大小做比较。如果当前大小比指定的百分比，重写机制就会被触发。#同时，你也要制定一个重写下线，用来避免增长百分比够了，但是日志文件还很小的情况。##指定百分比为0可以注掉自动重写日志文件功能。auto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mb 运行流程既然是log文件，而且是要用于恢复的，那么我们动动脚趾都能想到，这玩意肯定会越来越大，不管你的应用是大是小，如果AOF文件只增不减的话，那文件将会无限长大，这个问题是所有binlog都会遇到的。而通常遇到这种问题都会有一个rotate方案。就是当日志达到一定大小或者每隔一段时间将日志写到新的一个文件中，旧日志文件可以用来备份或其它。 而Redis的AOF还和rotate略有不同，他用了一种比较简单的方法，就是先给当前的所有数据做一个快照。然后再在这个快照的基础上写接下来的日志。照快照的好处是，你之前可能用了10w次操作共改变了100条数据（比如在一条数据上进行了多次操作）。那这时你AOF中的10w条写操作记录就变成了100条记录。相当于将前面的执行全部合并了。原本很大AOF变小了。 执行这个操作的命令是：BGREWRITEAOF （background rewrite append only file） 这个快照长什么样呢?基本和一般的写日志没什么两样，也是一条一条的写记录。。比如现在Redis中总共存了3条string类型的数据a=&gt;1，b=&gt;2，c=&gt;3。那这个快照的基本内容就是写入a=&gt;1，写入b=&gt;2，写入c=&gt;3。 这时候要用AOF进行恢复的时候，只要先执行了前面几条，就能够恢复当前状态，然后再执行之后来的写操作，就能完全重现数据了。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh-keygen 密钥]]></title>
    <url>%2F2016%2Fssh-keygen-%E5%AF%86%E9%92%A5%2F</url>
    <content type="text"><![CDATA[ssh-keygen 使用生成、管理和转换认证密钥 1234567891011121314151617181920212223242526$ ssh-keygen --helpssh-keygen: unknown option -- -usage: ssh-keygen [-q] [-b bits] [-t dsa | ecdsa | ed25519 | rsa | rsa1] [-N new_passphrase] [-C comment] [-f output_keyfile] ssh-keygen -p [-P old_passphrase] [-N new_passphrase] [-f keyfile] ssh-keygen -i [-m key_format] [-f input_keyfile] ssh-keygen -e [-m key_format] [-f input_keyfile] ssh-keygen -y [-f input_keyfile] ssh-keygen -c [-P passphrase] [-C comment] [-f keyfile] ssh-keygen -l [-v] [-E fingerprint_hash] [-f input_keyfile] ssh-keygen -B [-f input_keyfile] ssh-keygen -D pkcs11 ssh-keygen -F hostname [-f known_hosts_file] [-l] ssh-keygen -H [-f known_hosts_file] ssh-keygen -R hostname [-f known_hosts_file] ssh-keygen -r hostname [-f input_keyfile] [-g] ssh-keygen -G output_file [-v] [-b bits] [-M memory] [-S start_point] ssh-keygen -T output_file -f input_file [-v] [-a rounds] [-J num_lines] [-j start_line] [-K checkpt] [-W generator] ssh-keygen -s ca_key -I certificate_identity [-h] [-n principals] [-O option] [-V validity_interval] [-z serial_number] file ... ssh-keygen -L [-f input_keyfile] ssh-keygen -A ssh-keygen -k -f krl_file [-u] [-s ca_public] [-z version_number] file ... ssh-keygen -Q -f krl_file file ... -t 指定要创建的密钥类型，如：-t dsa | ecdsa | ed25519 | rsa | rsa1 123$ ssh-keygen -t ecdsaGenerating public/private ecdsa key pair.Enter file in which to save the key (/c/Users/Administrator/.ssh/id_ecdsa): -b bits 指定密钥长度。对于RSA密钥，最小要求768位，默认是2048位 123$ ssh-keygen -b 4096Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/Administrator/.ssh/id_rsa): -C comment 提供一个注释。生成git密钥的时候都会要求注释中写入邮箱名字。 123456789101112131415161718192021$ ssh-keygen -t rsa -b 4096 -C "your_email@example.com"Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/Administrator/.ssh/id_rsa): your_email #如果需要指定生成的文件名，就输入，否则就回车Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in jerry.myoss.Your public key has been saved in jerry.myoss.pub.The key fingerprint is:SHA256:zIF+Fqb8qIJsHq1nBV07DTuOvF6ucxhaaIBZcIk2/uE jerry.myoss@gmail.comThe key's randomart image is:+---[RSA 4096]----+|.o.. ||.+o + ||+o. . o O ||oo o + X + || + = * S || .E * * ||.o..+ =.. ||.o++ =o. ||ooo.oo+. |+----[SHA256]-----+ -f filename 指定密钥文件名 -l 显示公钥文件的指纹数据。它也支持 RSA1 的私钥。对于RSA和DSA密钥，将会寻找对应的公钥文件，然后显示其指纹数据。 12$ ssh-keygen -lf id_rsa.pub2048 SHA256:Ie1oJx+a9+iqZk1OUnUrJVH2e/aRFbGcfLvpG7YNJBY your_email@example.com (RSA) -E 用md5的方式查看指纹数据 12$ ssh-keygen -E md5 -lf id_rsa.pub2048 MD5:8a:f4:c3:8f:11:53:c9:12:a6:c0:3f:b9:70:a6:84:65 your_email@example.com (RSA) ssh密钥常见问题Permissions 0644 for ‘/root/.ssh/id_rsa’ are too open123456789101112131415[root@linux1 workspace]# git clone git@github.com:myoss/profile.gitInitialized empty Git repository in /root/workspace/profile/.git/The authenticity of host 'github.com (192.30.252.128)' can't be established.RSA key fingerprint is 16:27:ac:b5:76:28:2d:37:63:1b:56:3d:sb:df:a6:68.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added 'github.com,192.30.252.128' (RSA) to the list of known hosts.@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ WARNING: UNPROTECTED PRIVATE KEY FILE! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Permissions 0644 for '/root/.ssh/id_rsa' are too open.It is required that your private key files are NOT accessible by others.This private key will be ignored.bad permissions: ignore key: /root/.ssh/id_rsaPermission denied (publickey).fatal: The remote end hung up unexpectedly 出现以上的错误，需要将私钥的权限降级到0600 1[root@linux1 workspace]# chmod 0600 ~/.ssh/id_rsa 多个公钥与服务器上不同的GIT帐号交互国外很有名的：github.com，国内：git.oschina.net等等，我们可能会在上面注册多个账户，但是如何使用不同的公钥了？ 生成不同账户的密钥假设我现在有2个Github账户，账户名分别是：jerry1和jerry2，我先在本地生成两个密钥，然后将密钥的公钥分别添加到Github账户中 1234567$ ssh-keygen -t rsa -b 4096 -C "jerry1@myoss.com"Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/Administrator/.ssh/id_rsa): jerry1_rsa$ ssh-keygen -t rsa -b 4096 -C "jerry2@myoss.com"Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/Administrator/.ssh/id_rsa): jerry2_rsa 添加公钥到服务器的账户中将刚才生成的两个公钥，分别添加到github.com中（其它的网站也类似） 12345$ cat jerry1_rsa.pub #复制下面输出的内容，添加到github账户中ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQC+vhrJRJZHJnLB/hu+4M1WJpWv+VICFUE1P/spsuPE6VZuCsTi/QfO5g9/ekxKgaw0vZs6F568UQbZQV+u3c88t0YWbp6VlvgsPPjJAUw96UkLswMJRmfkwPkZdmrwv5xjLW6eC3xrV0jnZfwzVJl0OHuBMLwfYCwrRjKo8n1dqiQWaAFI6STJpYwj9862o+Bob86h+CQl5CpKsSViyhnHcdrSC498fYptkd2CbaQ8IL0ShLdi/uJAHbVv1cGRyDe/pHpfg9/exJWr9E8zmBHJ1rVYNXWcSJQiaB8sJ2Gqx/Lr8sW3iDaavJEw3y3agx5XWyPG8FDh60g/VHR9PURlkpO28jl8whxiVZbCXUreRZZQy3VCMY+JP73lXsb6a8YJ00PsM5OdTDm1PRQCPUxq492PbysSNeS+k7/RiOSBp1CE1xuWGhvJiZdNAF8pcxxe4Hvbg06PvoDIiyPl6Q0w6N//MNIjiVAJlb8+4Lqdo/EG96QtR8hjGi5j2Pkf2UU6PcmH1Cgb28xNwKorris4JUfHoYq9d7hQBpFOraSzsgM/M7x9QRYLi/3Up8aSXSbbHNrLN4gbIlEjEyb+AjG2WXSAkFNYr6LSRXa3V6KTLttR9Cxqo85WOsdQpJYjeeZVocfWlUkHwl3pSh/x/8GAkAj1J+XenGoJvc+upL13xw== jerry1@myoss.com$ cat jerry2_rsa.pubssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQDKn5jvaHbKnnZqDqDXpaos9CZZKWgdfYKK+oUWJ88hfjuD9GQOXcK23xedRQ8fXGGnuvNjjsKFHeJZOP70pSflQIladi6ZG2vNWtieDoWWfS65f8fEFd5kN7OS4GA9K7DHZkzr+IYm5tPjq9Znwvml2xN51BlJoqo0UUhPRKE+v7or3tqSS155LuEDyRBvHxA8TKeIK7TM80E2WDVaVzXvEFdgT5s3JrzmzVhgFjjJTS2dpER3DqSyhB168gMEE4Lhh+D+68vR6ED/7eFst0g7bBC5f8lAmAs7bWOFVKFkFTzOQj8nL4XM9ACZyCvgDMakLpOntQa/W9l4Av0FS5XFpMxm1Qza+SDycwIGYgAMDpiEiIzcuPiMFckGk8CV5C7ziV9oU+OZTYChskrnahaOJRZNvjGN/Y7kUIXjybgQUqwj25qxbmwXivT9OObKNtdT8lQZLdFPgBosT62aW0MpDKGg8JTGDG4IDfIXnOizz6PTT9s7XuIYFi23vsScFG/yttm7cUDsUKn9HI5bjv0u0YE7Q1oYYXZmq7ZdbJ5QgTjCY3OJhT+wZpiLdFdLFplj+OVT29PRVxB01njGqmuXrpij/AP9V3Hr2l7NM12xc597jOoDwBLHgxvt93jAzQTgsxalE0ZU73P/8ohnngWQiAi/vXe4oh8la7kj3gpe5Q== jerry2@myoss.com 配置ssh的config文件在用户家目录的.ssh中，创建或者编辑文件config 123456789101112$ cat ~/.ssh/configHost jerry1-githubHostName github.comuser gitPreferredAuthentications publickeyIdentityFile ~/.ssh/jerry1_rsaHost jerry2-githubHostName github.comuser gitPreferredAuthentications publickeyIdentityFile ~/.ssh/jerry2_rsa 测试是否能连接git服务器不输出错误信息，即连接成功。如果不是github账户，输出的信息和下面会不同 12345$ ssh -T jerry1-githubHi jerry1! You've successfully authenticated, but GitHub does not provide shell access.$ ssh -T jerry2-githubHi jerry2! You've successfully authenticated, but GitHub does not provide shell access. git服务器的仓库地址github中默认ssh方式的项目地址类似如下 123git@github.com:github的用户名/github的项目名字.gitgit@github.com:myoss/profile.git #比如：这是我的账户中的profile项目 这是时候克隆的ssh地址需要稍作改变 12345config文件中配置的Host名字:github的用户名/github的项目名字.gitgit clone jerry1-github:jerry1/github的项目名字.git #GitHub中jerry1的某某项目git clone jerry2-github:jerry2/github的项目名字.git #GitHub中jerry2的某某项目 如果你的项目已经克隆到本地磁盘了，那么就修改下远程仓库的地址 123git remote set-url &lt;仓库的简写名字&gt; &lt;新的仓库地址&gt;git remote set-url origin jerry1-github:jerry1/github的项目名字.git]]></content>
      <categories>
        <category>linux</category>
        <category>ssh</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>开发配置</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux 常用命令]]></title>
    <url>%2F2016%2Flinux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[开关机12shutdown -d now #立即关机reboot #重启 开机模式切换设置开机之后，进入到何种模式（图像界面、单用户、多用户等） 123456789101112131415161718192021222324252627[root@linux1 ~]# vi /etc/inittab # inittab is only used by upstart for the default runlevel.## ADDING OTHER CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM.## System initialization is started by /etc/init/rcS.conf## Individual runlevels are started by /etc/init/rc.conf## Ctrl-Alt-Delete is handled by /etc/init/control-alt-delete.conf## Terminal gettys are handled by /etc/init/tty.conf and /etc/init/serial.conf,# with configuration in /etc/sysconfig/init.## For information on how to write upstart event handlers, or how# upstart works, see init(5), init(8), and initctl(8).## Default runlevel. The runlevels used are:# 0 - halt (Do NOT set initdefault to this)# 1 - Single user mode 单用户命令行模式# 2 - Multiuser, without NFS (The same as 3, if you do not have networking)# 3 - Full multiuser mode 完整的多用户命令行模式# 4 - unused# 5 - X11 图形界面# 6 - reboot (Do NOT set initdefault to this)#id:3:initdefault: 从命令行模式切换到图形界面，需要在能够直接连接主机的地方（比如：VMware） 12[root@linux1 ~]# startx[root@linux1 ~]# init 5 #可能不起作用 在VMware虚拟主机模式下，从图形界面切换到命令行模式 123windows系统快捷键：ctrl + alt + F1[root@linux1 ~]# init 3 #可能不起作用 shell命令Shell是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行。实际上Shell是一个命令解释器，它解释由用户输入的命令并且把它们送到内核。 12[root@linux1 /]# echo $SHELL #查看当前环境使用的shell命令解释器/bin/bash 用户家目录root用户的家目录和其它账户的家目录位置不一样。$HOME和~都能代表当前用户的家目录 12345[root@linux1 /]# echo $HOME #查看当前用户的家目录/root[jerry@linux1 /]$ cd ~ #切换目录为当前用户的家目录[jerry@linux1 /]$ pwd #查看当前目录/home/jerry su命令12[jerry@linux1 /]$ su - root #切换用户为：rootPassword: id命令id命令可以显示真实有效的用户ID(UID)和组ID(GID)。UID是对一个用户的单一身份标识。组ID（GID）则对应多个UID。 12[root@linux1 ~]# iduid=0(root) gid=0(root) groups=0(root) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 uname命令uname是Linux命令用途显示当前操作系统名称 12345678910111213141516[root@linux1 ~]# unameLinux[root@linux1 ~]# uname -aLinux linux1.jerry.com 2.6.32-504.el6.x86_64 #1 SMP Tue Sep 16 01:56:35 EDT 2014 x86_64 x86_64 x86_64 GNU/Linux[root@linux1 ~]# uname -nlinux1.jerry.com[root@linux1 ~]# uname -inlinux1.jerry.com x86_64[root@linux1 ~]# uname -ix86_64[root@linux1 ~]# uname -r2.6.32-504.el6.x86_64[root@linux1 ~]# uname -sLinux[root@linux1 ~]# uname -rsLinux 2.6.32-504.el6.x86_64 date命令date命令打印或设置系统日期和时间 12[root@linux1 ~]# dateMon Feb 29 21:42:48 CST 2016 连续执行多条命令如果每个命令被;所分隔，那么命令会连续的执行下去 12345678[root@linux1 ~]# date; unameMon Feb 29 21:44:18 CST 2016Linux[root@linux1 ~]# date; unamed; ls #第二条命令出错了，但是第三天命令还是会执行Mon Feb 29 21:47:42 CST 2016-bash: unamed: command not foundanaconda-ks.cfg Documents install.log Music Public VideosDesktop Downloads install.log.syslog Pictures Templates 如果每个命令被&amp;&amp;分隔，那么这些命令会一直执行下去，如果中间有错误的命令存在，则不再执行后面的命令，没错则执行到完为止 123[root@linux1 ~]# date&amp;&amp; unamed&amp;&amp; lsMon Feb 29 21:49:05 CST 2016-bash: unamed: command not found 如果每个命令被||分隔，如果命令遇到可以成功执行的命令，那么命令停止执行，即使后面还有正确的命令则后面的所有命令都将得不到执行。假如命令一开始就执行失败，那么就会执行||后的下一个命令，直到遇到有可以成功执行的命令为止，假如所有的都失败，则所有这些失败的命令都会被尝试执行一次 123456789[root@linux1 ~]# date || unamed || lsMon Feb 29 21:50:58 CST 2016[root@linux1 ~]# unamed || date || ls-bash: unamed: command not foundMon Feb 29 21:51:12 CST 2016[root@linux1 ~]# unamed || dated || lsd-bash: unamed: command not found-bash: dated: command not found-bash: lsd: command not found man命令操作手册Linux系统提供了相对比较丰富的帮助手册（man），man是manual的缩写，在日常linux系统管理中经常用到 1man ls 快捷键操作 下一页 空格键 回车键 上一页 B键 搜索输入/bala向下搜索字符串bala，输入?bala向上搜索字符串bala。N键继续关键字的下一个搜索，N键反向搜索关键字。 退出manQ键退出man命令 stat命令stat打印信息节点(inode)内容 12345678910111213141516[root@linux1 ~]# stat Videos/ File: `Videos/' Size: 4096 Blocks: 8 IO Block: 4096 directoryDevice: fd00h/64768d Inode: 275645 Links: 2Access: (0755/drwxr-xr-x) Uid: ( 0/ root) Gid: ( 0/ root)Access: 2015-12-28 06:34:48.950999982 +0800Modify: 2015-12-28 06:34:48.950999982 +0800Change: 2015-12-28 06:34:48.950999982 +0800[root@linux1 ~]# stat Public/ File: `Public/' Size: 4096 Blocks: 8 IO Block: 4096 directoryDevice: fd00h/64768d Inode: 275641 Links: 2Access: (0755/drwxr-xr-x) Uid: ( 0/ root) Gid: ( 0/ root)Access: 2015-12-28 06:34:48.950999982 +0800Modify: 2015-12-28 06:34:48.950999982 +0800Change: 2015-12-28 06:34:48.950999982 +0800 more命令more在显示器上阅读文件的过滤器, 用于分页显示 (一次一屏) 文本. 这个版本非常基本. less提供了more的模拟, 并且做了增强 1[root@linux1 ~]# more install.log #查看文件，一次一屏 快捷键操作 下一页 空格键 上一页 B键 下一行 回车键 退出 Q键 less命令less与more类似，但使用less可以更方便随意浏览文件，less在查看之前不会加载整个文件 1[root@linux1 ~]# ps -ef | less #ps查看进程信息并通过less分页显示 快捷键操作 下一页 空格键 上一页 B键 下一行 回车键 方向键下 上一行 方向键上 退出 Q键 搜索输入/bala向下搜索字符串bala，输入?bala向上搜索字符串bala。N键继续关键字的下一个搜索，N键反向搜索关键字。 head命令在标准输出上显示每个FILE的起始10行。如果多于一个FILE，则一个接一个地显示，并且在每个文件显示的首部给出文件名。如果没有FILE或者FILE为-，那么就从标准输入上读取 -c, --bytes=[-]K 显示起始的SIZE字节。b表示512, kB表示1000, K表示1024, MB表示10001000, M表示10241024, GB表示100010001000, G表示102410241024 123[root@linux1 ~]# head --bytes=1k install.log[root@linux1 ~]# head -c 1k install.log[root@linux1 ~]# head -c 1m install.log -n, --lines=[-]K 显示起始的NUMBER行，而非默认的起始10行 123[root@linux1 ~]# head -n 2 install.log[root@linux1 ~]# head --lines 2 install.log[root@linux1 ~]# head --lines=2 install.log -q, --quiet, --silent 当输出多个文件的时候才会显示出差异，不输出文件名的首部 1234567891011121314[root@linux1 ~]# head install.log install.log.syslog -n 2==&gt; install.log &lt;== #输出了文件的名字Installing libgcc-4.4.7-11.el6.x86_64warning: libgcc-4.4.7-11.el6.x86_64: Header V3 RSA/SHA256 Signature, key ID fd431d51: NOKEY==&gt; install.log.syslog &lt;== #输出了文件的名字&lt;86&gt;Dec 28 06:01:22 groupadd[1541]: group added to /etc/group: name=dbus, GID=81&lt;86&gt;Dec 28 06:01:22 groupadd[1541]: group added to /etc/gshadow: name=dbus[root@linux1 ~]#[root@linux1 ~]# head install.log install.log.syslog -q -n 2 #没有输出文件的名字Installing libgcc-4.4.7-11.el6.x86_64warning: libgcc-4.4.7-11.el6.x86_64: Header V3 RSA/SHA256 Signature, key ID fd431d51: NOKEY&lt;86&gt;Dec 28 06:01:22 groupadd[1541]: group added to /etc/group: name=dbus, GID=81&lt;86&gt;Dec 28 06:01:22 groupadd[1541]: group added to /etc/gshadow: name=dbus tail命令在标准输出上显示每个FILE的最后10行。如果多于一个FILE，会一个接一个地显示，并在每个文件显示的首部给出文件名。如果没有FILE，或者FILE是-，那么就从标准输入上读取 -c, --bytes=[-]K 显示最后的SIZE字节。b表示512, kB表示1000, K表示1024, MB表示10001000, M表示10241024, GB表示100010001000, G表示102410241024 123[root@linux1 ~]# tail --bytes=1k install.log[root@linux1 ~]# tail -c 1k install.log[root@linux1 ~]# tail -c 1m install.log -n, --lines=[-]K 显示最后的NUMBER行，而非默认的最后10行 123[root@linux1 ~]# tail -n 2 install.log[root@linux1 ~]# tail --lines 2 install.log[root@linux1 ~]# tail --lines=2 install.log -f, --follow[={name|descriptor}] 当文件增长时，输出后续添加的数据；-f, --follow以及--follow=descriptor都是相同的意思。常用于查看日志文件 1[root@linux1 ~]# tail -f install.log --retry 即使tail开始时就不能访问或者在tail运行后不能访问，也仍然不停地尝试打开文件。--只与-f合用时有用 12345[root@linux1 ~]# tail -f --retry kawaii.logtail: warning: --retry only effective for the initial opentail: cannot open ‘logs/kawaii.log’ for reading: No such file or directorytail: ‘logs/kawaii.log’ has appeared; following end of new file2016-03-02 20:45:58,525 [pool-2-thread-1] INFO bala -q, --quiet, --silent 当输出多个文件的时候才会显示出差异，不输出文件名的首部 123456789101112[root@linux1 ~]# tail install.log install.log.syslog -n 2==&gt; install.log &lt;== #输出了文件的名字Installing compat-libstdc++-296-2.96-144.el6.i686*** FINISHED INSTALLING PACKAGES ***==&gt; install.log.syslog &lt;== #输出了文件的名字&lt;86&gt;Dec 28 06:10:27 groupadd[4346]: group added to /etc/gshadow: name=slocate&lt;86&gt;Dec 28 06:10:27 groupadd[4346]: new group: name=slocate, GID=21[root@linux1 ~]#[root@linux1 ~]# tail install.log install.log.syslog -q -n 2 #没有输出文件的名字Installing compat-libstdc++-296-2.96-144.el6.i686*** FINISHED INSTALLING PACKAGES ***&lt;86&gt;Dec 28 06:10:27 groupadd[4346]: group added to /etc/gshadow: name=slocate&lt;86&gt;Dec 28 06:10:27 groupadd[4346]: new group: name=slocate, GID=21 cp命令cp复制文件（或者目录等）。可以使用这个命令复制一个文件到一个指定的目的地，或者复制任意多个文件到一个目的目录目录 如果最后一个命令参数为一个已经存在的目录名，cp会将每一个源文件复制到那个目录下（维持原文件名）。如果所给的参数只有两个文件名，它把前一个文件复制到后一个文件上。如果最后一个参数不是文件名、目录名和给出多于两个非选项参数，这是错误的语法 12345678[root@linux1 Desktop]# lltotal 4-rw-r--r--. 1 root root 9 Mar 2 21:27 test.txt[root@linux1 Desktop]# cp test.txt test2.txt[root@linux1 Desktop]# lltotal 8-rw-r--r--. 1 root root 9 Mar 2 21:28 test2.txt-rw-r--r--. 1 root root 9 Mar 2 21:27 test.txt -p 保留原文件的所有者、组、权限（包括setuid和setgid位），上次修改时间和上次访问时间。如果制作所有者或组信息的副本时出错，则setuid和setgid位被清空。 123456[root@linux1 Desktop]# cp test.txt test3.txt -p[root@linux1 Desktop]# lltotal 12-rw-r--r--. 1 root root 9 Mar 2 21:28 test2.txt-rw-r--r--. 1 root root 9 Mar 2 21:27 test3.txt-rw-r--r--. 1 root root 9 Mar 2 21:27 test.txt -i 提示是否覆盖已经存在的目标文件。在ReadHat linux系统里，cp命令默认添加了-i选项 12[root@linux1 Desktop]# alias cpalias cp='cp -i' -R, -r 递归复制目录 -v, --verbose 在复制前印出文件名 123[root@linux1 Desktop]# cp test.txt test3.txt -vcp: overwrite `test3.txt'? y`test.txt' -&gt; `test3.txt' -n 不覆盖已经存在的目标文件 12[root@linux1 Desktop]# cp test.txt test3.txt -v -n[root@linux1 Desktop]#]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux 修改hostname]]></title>
    <url>%2F2016%2Flinux-%E4%BF%AE%E6%94%B9hostname%2F</url>
    <content type="text"><![CDATA[立即生效，非永久保存此种方式修改，会立即生效，但是在重启系统之后会被还原 123[root@linux1 ~]# hostname linux2.jerry.com[root@linux1 ~]# hostnamelinux2.jerry.com 重启后生效，永久保存此种方式修改，不会立即生效，但在重启之后会生效 1234[root@linux1 ~]# cat /etc/sysconfig/networkNETWORKING=yesHOSTNAME=linux2.jerry.comNTPSERVERARGS=iburst 以上两种方式结合，即能做到立即生效并永久保存剖析hostname的设置hostname是Linux系统下的一个内核参数，它保存在/proc/sys/kernel/hostname下，但是它的值是Linux启动时从rc.sysinit读取的 123456789101112131415161718[root@linux1 ~]# vi /etc/rc.d/rc.sysinit #!/bin/bash## /etc/rc.d/rc.sysinit - run once at boot time## Taken in part from Miquel van Smoorenburg's bcheckrc.#HOSTNAME=$(/bin/hostname)set -mif [ -f /etc/sysconfig/network ]; then . /etc/sysconfig/networkfiif [ -z "$HOSTNAME" -o "$HOSTNAME" = "(none)" ]; then HOSTNAME=localhostfi 结论：/etc/sysconfig/network确实是hostname的配置文件，hostname的值跟该配置文件中的HOSTNAME有一定的关联关系，但是没有必然关系，hostname的值来自内核参数/proc/sys/kernel/hostname，如果我通过命令sysctl kernel.hostname=Test修改了内核参数，那么hostname就变为了Test了 123456789101112[root@linux1 ~]# cat /proc/sys/kernel/hostnamelinux2.jerry.com[root@linux1 ~]# sysctl kernel.hostname=Test #修改内核参数kernel.hostname = Test[root@linux1 ~]# hostname #hostname已经被修改了Test[root@linux1 ~]# cat /proc/sys/kernel/hostname #内核参数也变化了Test[root@linux1 ~]# cat /etc/sysconfig/network #hostname的配置文件没有变化NETWORKING=yesHOSTNAME=linux2.jerry.comNTPSERVERARGS=iburst]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux 网卡设置/虚拟机克隆后网卡启动失败]]></title>
    <url>%2F2016%2Flinux-%E7%BD%91%E5%8D%A1%E8%AE%BE%E7%BD%AE-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%85%8B%E9%9A%86%E5%90%8E%E7%BD%91%E5%8D%A1%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5%2F</url>
    <content type="text"><![CDATA[静态IP设置12345678910111213141516171819202122232425262728293031323334353637[root@linux1 ~]# cat /etc/sysconfig/network-scripts/ifcfg-eth0 DEVICE=eth0NAME="System eth0"TYPE=EthernetUUID=9dc04a99-b654-4673-9b19-5100a2b03c51NM_CONTROLLED=yesONBOOT=yes #开机自动启用此网卡设置BOOTPROTO=static #启用静态IP地址IPADDR=192.168.245.201 #设置IP地址GATEWAY=192.168.245.2 #设置网关NETMASK=255.255.255.0 #设置子网掩码DNS1=114.114.114.114 #设置主DNSHWADDR=00:0C:29:D1:9C:4D #网卡mac地址PREFIX=24DEFROUTE=yesIPV4_FAILURE_FATAL=yesIPV6INIT=noLAST_CONNECT=1451228780[root@linux1 ~]# cat /etc/sysconfig/network-scripts/ifcfg-eth0DEVICE=eth0NAME="System eth0"TYPE=EthernetUUID=9dc04a99-b654-4673-9b19-5100a2b03c51NM_CONTROLLED=yesONBOOT=yesBOOTPROTO=staticIPADDR=192.168.245.201GATEWAY=192.168.245.2NETMASK=255.255.255.0DNS1=114.114.114.114HWADDR=00:0C:29:D1:9C:4DPREFIX=24DEFROUTE=yesIPV4_FAILURE_FATAL=yesIPV6INIT=noLAST_CONNECT=1451228780 虚拟机中克隆linux后网卡启动失败克隆的linux主机在启动之后，mac地址发生了变化或者冲突了，重启网卡会出现以下错误 12345[root@linux1 rules.d]# service network restartShutting down loopback interface: [ OK ]Bringing up loopback interface: [ OK ]Bringing up interface eth0: Error: No suitable device found: no device found for connection 'System eth0'. [FAILED] 解决办法：我们需要修改mac地址linux主机启动之后，会多出一个DHCP自动分配的网卡eth1（如果没有，通过图形界面配置一个自动获取IP的网卡），找到HWaddr 00:0C:29:D1:9C:4D这一串信息，我们要用到的是新的网卡mac地址：00:0C:29:D1:9C:4D 123456789101112131415161718[root@linux1 Desktop]# startx #进入linux图形界面[root@linux1 Desktop]# ifconfig #查看所有网卡信息eth1 Link encap:Ethernet HWaddr 00:0C:29:D1:9C:4D inet6 addr: fe80::20c:29ff:fed1:9c4d/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:1574 errors:0 dropped:0 overruns:0 frame:0 TX packets:153 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:108954 (106.4 KiB) TX bytes:13586 (13.2 KiB)lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 inet6 addr: ::1/128 Scope:Host UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:62 errors:0 dropped:0 overruns:0 frame:0 TX packets:62 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:4212 (4.1 KiB) TX bytes:4212 (4.1 KiB) 修改网卡eth0配置中的HWADDR值（网卡mac地址），使用上面的新mac地址：00:0C:29:D1:9C:4D 123456789101112131415161718[root@linux1 Desktop]# vi /etc/sysconfig/network-scripts/ifcfg-eth0[root@linux1 Desktop]# cat /etc/sysconfig/network-scripts/ifcfg-eth0 DEVICE=eth0TYPE=EthernetUUID=9dc04a99-b654-4673-9b19-5100a2b03c51ONBOOT=yesNM_CONTROLLED=yesBOOTPROTO=noneIPADDR=192.168.245.201PREFIX=24GATEWAY=192.168.245.2DNS1=114.114.114.114DEFROUTE=yesIPV4_FAILURE_FATAL=yesIPV6INIT=noNAME="System eth0"HWADDR=00:0C:29:D1:9C:4DLAST_CONNECT=1451228780 修改/etc/udev/rules.d/70-persistent-net.rules配置中的mac地址，改成和上面的一致 12345678910[root@linux1 rules.d]# vi /etc/udev/rules.d/70-persistent-net.rules[root@linux1 rules.d]# cat /etc/udev/rules.d/70-persistent-net.rules# This file was automatically generated by the /lib/udev/write_net_rules# program, run by the persistent-net-generator.rules rules file.## You can modify it, as long as you keep each rule on a single# line, and change only the value of the NAME= key.# PCI device 0x8086:0x100f (e1000)SUBSYSTEM==&quot;net&quot;, ACTION==&quot;add&quot;, DRIVERS==&quot;?*&quot;, ATTR&#123;address&#125;==&quot;00:0C:29:D1:9C:4D&quot;, ATTR&#123;type&#125;==&quot;1&quot;, KERNEL==&quot;eth*&quot;, NAME=&quot;eth0&quot; 删除掉网卡eth1（如果不需要的话），重启网卡就能生效了 123[root@linux1 rules.d]# ifup eth0Active connection state: activatedActive connection path: /org/freedesktop/NetworkManager/ActiveConnection/3]]></content>
      <categories>
        <category>linux</category>
        <category>网络设置</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux mount/umount 挂载/卸载ISO镜像]]></title>
    <url>%2F2016%2Flinux-mount-umount-%E6%8C%82%E8%BD%BD-%E5%8D%B8%E8%BD%BDISO%E9%95%9C%E5%83%8F%2F</url>
    <content type="text"><![CDATA[虚拟机加载ISO镜像在VMWare中的Linux虚拟机设置ISO镜像文件的路径，先完成设置，接着连接 mount挂载先在/media目录下创建cdrom文件夹，用于统一的挂载ISO镜像文件，这样便于日常操作 12[root@linux1 /]# cd /media[root@linux1 media]# mkdir cdrom linux光驱加载的文件路径默认是在/dev/cdrom目录下，但不能操作也不能像文件夹那样直接操作，所以用mount命令挂载到物理路径 123456[root@linux1 cdrom]# mount /dev/cdrom /media/cdrom/mount: block device /dev/sr0 is write-protected, mounting read-only[root@linux1 media]# ll cdrom/ #接下来就可以像普通文件夹一样操作ISO镜像中的文件夹了，但这只是只读的喔l^H^H^H^H^H^H^H^H^H^Htotal 863dr-xr-xr-x. 3 root root 2048 Sep 26 2014 EFI-r--r--r--. 1 root root 8724 Nov 7 2012 EULA 配置简单的本地YUM源baseurl：文件的路径；enabled：启用当前yum源；gpgcheck：gpg检查不启用 1234567[root@linux1 ~]# cd /etc/yum.repos.d/[root@linux1 yum.repos.d]# cat rhel6-iso.repo [rhel-source]name=Red Hat Enterprise Linux 6 ISObaseurl=file:///media/cdromenabled=1gpgcheck=0 测试本地YUM源是否配置好了 1234567891011121314151617181920212223242526272829303132333435363738[root@linux1 yum.repos.d]# yum clean all #清空缓存Loaded plugins: product-id, refresh-packagekit, security, subscription-managerThis system is not registered to Red Hat Subscription Management. You can use subscription-manager to register.Cleaning repos: rhel-sourceCleaning up Everything[root@linux1 yum.repos.d]# yum list vsftp* #查找软件Loaded plugins: product-id, refresh-packagekit, security, subscription-managerThis system is not registered to Red Hat Subscription Management. You can use subscription-manager to register.rhel-source | 4.1 kB 00:00 ... rhel-source/primary_db | 3.1 MB 00:00 ... Available Packagesvsftpd.x86_64 2.2.2-12.el6_5.1 rhel-source[root@linux1 yum.repos.d]# yum install vsftpd.x86_64 #安装软件Loaded plugins: product-id, refresh-packagekit, security, subscription-managerThis system is not registered to Red Hat Subscription Management. You can use subscription-manager to register.Setting up Install ProcessResolving Dependencies--&gt; Running transaction check---&gt; Package vsftpd.x86_64 0:2.2.2-12.el6_5.1 will be installed--&gt; Finished Dependency ResolutionDependencies Resolved======================================================================================================================================================================= Package Arch Version Repository Size=======================================================================================================================================================================Installing: vsftpd x86_64 2.2.2-12.el6_5.1 rhel-source 151 kTransaction Summary=======================================================================================================================================================================Install 1 Package(s)Total download size: 151 kInstalled size: 331 kIs this ok [y/N]: n #输入“n”取消安装Exiting on user Command[root@linux1 yum.repos.d]# 卸载ISO镜像【重要】使用完了，记得一定要卸载掉喔~~~ 123[root@linux1 media]# umount /media/cdrom[root@linux1 media]# ll cdrom/total 0 如果要退出光驱，可以使用以下命令 1[root@linux1 media]# eject /dev/cdrom]]></content>
      <categories>
        <category>linux</category>
        <category>mount</category>
        <category>yum</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis Plugin 学习使用]]></title>
    <url>%2F2016%2FMyBatis-Plugin-%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[关于本教程以下教程仅供学习使用，针对于IntelliJ Idea 15（目前已经支持IntelliJ Idea 2016）中的Mybatis Plugin插件（https://plugins.jetbrains.com/plugin/7293?pr=idea），后续作者会抽业余时间更新 如果你觉得本项目能帮助到你，那就Fork一下吧项目地址：https://github.com/myoss/profile 下载插件前提你已经在IntelliJ Idea中安装好了Mybatis Plugin，并且重启过了IntelliJ Idea。 下载profile项目（项目地址：https://github.com/myoss/profile）之后，找到目录：profile\idea\plugin\MybatisPlugin，并选择IntelliJ Idea中安装Mybatis Plugin的版本 1git clone git@github.com:myoss/profile.git windows系统查找Idea插件配置目录IntelliJ Idea安装Mybatis Plugin之后，默认保存的位置如下，前提你没有更改过IntelliJ Idea配置目录 1C:\Users\你的账户目录\.IntelliJIdea15\config\plugins\mybatis_plus\lib 替换class文件用WinRAR打开mybatis_plus.jar，将目录profile\idea\plugin\MybatisPlugin\对应的版本号\下的com文件夹拖进WinRAR，根据提示覆盖即可 重启IntelliJ Idea就这样完成了，教程完毕 mac os系统由于mac os中IntelliJ Idea的配置文件目录不一致，所以配置起来有些不一样。linux系统中应该类似，我没有验证，如果有兄弟验证过还请告诉我，感谢 查找Idea插件配置目录使用find命令在你的用户目录下查找mybatis_plus.jar这个文件（前提你没有更改过IntelliJ Idea的配置目录，如果更改了从根目录下查找吧，花费的时间可能会多点） 12345$ find ~ -name "mybatis_plus.jar"/Users/jerry-osx-m/Library/Application Support/IntelliJIdea15/mybatis_plus/lib/mybatis_plus.jar$ find ~ -name "mybatis_plus.jar"/Users/Jerry/Library/Application Support/IntelliJIdea2016.1/mybatis_plus/lib/mybatis_plus.jar 替换class文件方法1，在windows系统中将mybatis_plus.jar包替换好，然后替换掉mac的mybatis_plus.jar即可。 方法2，在mac 终端中，使用以下命令进行替换 1234567891011121314151617181920212223242526272829303132$ pwd/Users/jerry/Library/Application Support/IntelliJIdea2016.3/mybatis_plus/lib$ lsmybatis-generator-core-1.3.2.jar mybatis_plus.jar ref.idea.common-1.0.jar# 将要使用版本的 com 文件复制到当前目录中$ cp -R ~/workspaces/github/profile/idea/plugin/MybatisPlugin/v2.7~v2.87/ .$ lscom mybatis_plus.jarmybatis-generator-core-1.3.2.jar ref.idea.common-1.0.jar# 使用 jar 命令进行替换，注意 com 文件夹一定要当前目录下面$ jar uvf mybatis_plus.jar com正在添加: com/(输入 = 0) (输出 = 0)(存储了 0%)正在添加: com/seventh7/(输入 = 0) (输出 = 0)(存储了 0%)正在添加: com/seventh7/mybatis/(输入 = 0) (输出 = 0)(存储了 0%)正在添加: com/seventh7/mybatis/dom/(输入 = 0) (输出 = 0)(存储了 0%)正在添加: com/seventh7/mybatis/dom/model/(输入 = 0) (输出 = 0)(存储了 0%)正在添加: com/seventh7/mybatis/ref/(输入 = 0) (输出 = 0)(存储了 0%)正在添加: com/seventh7/mybatis/ref/license/(输入 = 0) (输出 = 0)(存储了 0%)正在添加: com/seventh7/mybatis/ref/license/ActivationDriver$1.class(输入 = 1926) (输出 = 797)(压缩了 58%)正在添加: com/seventh7/mybatis/ref/license/ActivationDriver.class(输入 = 1398) (输出 = 656)(压缩了 53%)正在添加: com/seventh7/mybatis/ref/RefProject$1.class(输入 = 2224) (输出 = 1092)(压缩了 50%)正在添加: com/seventh7/mybatis/ref/RefProject.class(输入 = 1982) (输出 = 919)(压缩了 53%)正在添加: com/seventh7/mybatis/service/(输入 = 0) (输出 = 0)(存储了 0%)正在添加: com/seventh7/mybatis/service/JavaService$1.class(输入 = 1408) (输出 = 613)(压缩了 56%)正在添加: com/seventh7/mybatis/service/JavaService$2.class(输入 = 1312) (输出 = 575)(压缩了 56%)正在添加: com/seventh7/mybatis/service/JavaService.class(输入 = 10921) (输出 = 4166)(压缩了 61%)正在添加: com/seventh7/mybatis/util/(输入 = 0) (输出 = 0)(存储了 0%)正在添加: com/seventh7/mybatis/util/JavaUtils$SystemData.class(输入 = 3412) (输出 = 1602)(压缩了 53%)正在添加: com/seventh7/mybatis/util/JavaUtils.class(输入 = 13339) (输出 = 4773)(压缩了 64%)正在添加: com/seventh7/mybatis/dom/model/Completion.class(输入 = 1663) (输出 = 923)(压缩了 44%) 方法3，参考网友在mac中使用类似 WinRar 软件进行替换：点击我跳转 重启IntelliJ Idea就这样完成了，教程完毕]]></content>
      <categories>
        <category>IntelliJ Idea</category>
      </categories>
      <tags>
        <tag>开发配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的 JavaScript 库 CDN 加速服务]]></title>
    <url>%2F2016%2F%E5%B8%B8%E7%94%A8%E7%9A%84-JavaScript-%E5%BA%93-CDN-%E5%8A%A0%E9%80%9F%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[CDN公共库CDN公共库是指将常用的源JavaScrit库存放在CDN节点，以方便广大开发者直接调用。与将JavaScrit库存放在服务器单机上相比，CDN公共库更加稳定、高速。一般的CDN公共库都会包含全球所有最流行的开源JavaScript库，你可以在自己的网页上直接通过script标记引用这些资源。这样做不仅可以为您节省流量，还能通过CDN加速，获得更快的访问速度。 国内的公共库 百度CDN公共库：http://developer.baidu.com/wiki/index.php?title=docs/cplat/libs 百度静态资源公共库：http://cdn.code.baidu.com/ 新浪云计算CDN公共库：http://lib.sinaapp.com BootCDN公共库：http://www.bootcdn.cn 360公共库：http://libs.useso.com 七牛云存储 开放静态文件CDN：http://www.staticfile.org 又拍云JS库CDN服务：http://jscdn.upai.com 国外的公共库 CDNJS：http://www.cdnjs.com Google Hosted Libraries：https://developers.google.com/speed/libraries/ Microsoft ASP.net CDN：http://www.asp.net/ajaxlibrary/cdn.ashx jsDelivr：http://www.jsdelivr.com/]]></content>
      <categories>
        <category>CDN</category>
        <category>JS公共库</category>
      </categories>
      <tags>
        <tag>网站优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ Idea 常用插件]]></title>
    <url>%2F2016%2FIntelliJ-Idea-%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[常用插件列表123456789Eclipse ActionEclipse Code FormatterSave ActionsString ManipulationFindBugs-IDEALombok PluginMyBatis PlugingfmCMD Support Eclipse Action实现Eclipse中快速复制行或者区块代码将Duplicate Lines Ex和Copy Lines Ex设置成你习惯的快捷键。插件源码地址：https://github.com/dgt79/EclipseActions Eclipse Code Formatter实现Eclipse中代码格式化功能如果你需要和使用Eclipse同事共同开发，为了防止代码在merge的时候出现冲突，你们肯定是要先定义好统一的格式化代码模板，这个xml从Eclipse中导出来，建议保存在IntelliJ Idea的配置目录下面，方便做配置同步插件源码地址：https://github.com/krasa/EclipseCodeFormatter Save Actions保存修改的时候自动导入、格式化代码IntelliJ Idea的默认配置是自动保存修改的内容，也就是不用你每次修改完了之后使用Ctrl + S进行保存，此插件能够帮助你每次修改内容之后，都能自动格式化、重新排序package的顺序，这些繁琐容易忘记的事情都帮你自动完成了，何乐而不为了插件源码地址：https://github.com/dubreuia/intellij-plugin-save-actions String Manipulation字符串快速格式转换使用方法，Alt + M选中你要操作的字符，举例你要快速将变量名转换成常量名（通常都是字母大写，并且两个字母之间使用_隔开，比如：DATE_TIME）插件源码地址：https://github.com/krasa/StringManipulation 转换后的效果： FindBugs-IDEA这个就不用说太多了，分析代码bug的插件地址：http://andrepdo.github.io/findbugs-idea/ Lombok Plugin支持lombok 注解，IntelliJ Idea默认是不支持了，会报语法错误，安装这个插件之后就可以了插件源码地址：https://github.com/mplushnikov/lombok-intellij-plugin 123456@Data ：注解在类上；提供类所有属性的 getting 和 setting 方法，此外还提供了equals、canEqual、hashCode、toString 方法@Setter：注解在属性上；为属性提供 setting 方法@Getter：注解在属性上；为属性提供 getting 方法@Log4j ：注解在类上；为类提供一个 属性名为log 的 log4j 日志对象@NoArgsConstructor：注解在类上；为类提供一个无参的构造方法@AllArgsConstructor：注解在类上；为类提供一个全参的构造方法 MyBatis Plugin支持MyBatis的一个不错插件，可惜现在要收费了，免注册使用方法：https://github.com/myoss/profile/tree/master/idea/plugin/MybatisPlugin插件地址：codesmagic gfmGitHub的GitHub Flavored Markdown插件源码地址：https://github.com/shyykoserhiy/gfm-plugin CMD Support可以在IntelliJ Idea中执行cmd脚本插件源码地址：https://github.com/t3hnar/CmdSupport]]></content>
      <categories>
        <category>IntelliJ Idea</category>
      </categories>
      <tags>
        <tag>开发配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ Idea 设置中的Copyright和scopes关联起来]]></title>
    <url>%2F2016%2FIntelliJ-Idea-%E8%AE%BE%E7%BD%AE%E4%B8%AD%E7%9A%84Copyright%E5%92%8Cscopes%E5%85%B3%E8%81%94%E8%B5%B7%E6%9D%A5%2F</url>
    <content type="text"><![CDATA[Copyright和scopes关联起来的原因每个公司或者现在的开源项目大都是有Copyright的，而我的配置都是同步到GitHub上的，所以不想写死了难切换，琢磨着是否可以动态的根据package name来关联不同的Copyright。以下设置是在IntelliJ Idea 15中完成的。 新增加一个CopyrightSettings中的菜单位置Ctrl + Alt + s 打开Settings，找到Editor -&gt; Copyright -&gt; Copyright Profiles 新增加一个ScopesSettings中的菜单位置Ctrl + Alt + s 打开Settings，找到Appearance &amp; Behavior -&gt; Scopes，切记一定要选择Shared类型，设置好之后，点击Apply然后退出Settings，记住一定要先保存，才去做下一步操作 关联Copyright和ScopeSettings中的菜单位置Ctrl + Alt + s 打开Settings，找到Editor -&gt; Copyright，在Scope的下拉菜单中选择第二步添加的Scope名字]]></content>
      <categories>
        <category>IntelliJ Idea</category>
      </categories>
      <tags>
        <tag>开发配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ Idea 配置同步]]></title>
    <url>%2F2016%2FIntelliJ-Idea-%E9%85%8D%E7%BD%AE%E5%90%8C%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[为什么要同步配置？初期从Eclipse转到IntelliJ Idea上来，最大的一个问题就是很多地方都不习惯，最最最主要的就是不习惯快捷键，所以我上来就是折腾快捷键的配置，让快捷键尽量和Eclipse的靠拢，花了好些天时间配置好了并且习惯了。这磨合的期间又有了新的需求，工作时间是在公司的电脑，非工作时间在家里的电脑，怎么快速同步配置了？在用户目录下找到了IntelliJ Idea的配置目录，想到了用GitHub仓库来同步，于是就这么干了，虽然不能做到很好的隔离配置差异，但是效果还是不错的，尤其是在重装电脑或者换公司的时候，重新git clone下仓库就能恢复配置了 windows系统同步配置方法找到配置目录如果没有更改过IntelliJ Idea的配置目录，那么它保存在如下的目录 1C:\Users\你的账户名\.IntelliJIdea15\config 初始化仓库将要忽略的文件，添加到.gitignore中（.gitignore语法参考），然后提交 12345cd ~/.IntelliJIdea15/configgit inittouch .gitignoregit add .git commit -m "init" 同步到仓库第一次请先在GitHub中创建一个仓库，然后按照提示进行操作，之后就是git push/pull操作啦。可以参考我的IntelliJ Idea的配置仓库，链接：https://github.com/myoss/IntelliJIdea-config Mac/Linux系统的配置IntelliJ Idea的配置似乎不是在同一个目录下，没有深入研究]]></content>
      <categories>
        <category>IntelliJ Idea</category>
      </categories>
      <tags>
        <tag>开发配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git操作]]></title>
    <url>%2F2016%2FGit%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[花了好几天的时间，才迁移完git学习笔记，进行了重新整理，记录了常用操作。不知不觉Git已经用了2年的时间，虽然不久，但已经深深爱上了这个家伙~~~ git config使用方法如下，如果没有指定位置参数省略的话，大部分命令默认为：--local 1git config [&lt;--system&gt; | &lt;--global&gt; | &lt;--local&gt;] [option] 配置优先级配置生效优先级：1. &gt; 2. &gt; 3.，即相同参数的配置优先级 .git/config 工作目录下的配置，使用：git config --local ~/.gitconfig 用户目录下的配置，使用：git config --global /etc/gitconfig 对所有用户都适用的配置，使用：git cofing --system 选项查看生效的配置12345678git config -l #查看所有配置git config --list #查看所有配置git config --system -l #查看系统用户的所有配置git config --system --list #查看系统用户的所有配置git config --global -l #查看当前用户的所有配置git config --global --list #查看当前用户的所有配置git config --local -l #查看当前工作目录下的所有配置git config --local --list #查看当前工作目录下的所有配置 查看某个参数的配置123git config user.name #查看当前工作目录下的“用户名称”的配置git config --local user.name #查看当前工作目录下的“用户名称”的配置，可以省略：--localgit config --global user.name #查看当前用户的“用户名称”的配置 设置用户名称和用户Email地址1234git config --global user.name "John Doe"git config --global user.email johndoe@example.comgit config --local user.name "John Doe"git config --local user.email johndoe@example.com 换行符：CRLF/LF在Windows系统上，把它设置成true，这样当签出代码时，LF会被转换成CRLF 1git config --global core.autocrlf true Linux或Mac系统上，因此你不想Git在签出文件时进行自动的转换；当一个以CRLF为行结束符的文件不小心被引入时你肯定想进行修正，设置成input来告诉Git在提交时把CRLF转换成LF，签出时不转换 1git config --global core.autocrlf input 如果仅运行在Windows上的项目，可以设置false取消此功能，把回车符记录在库中 1git config --global core.autocrlf false 换行符：SafeCRLF拒绝提交包含混合换行符的文件 1git config --global core.safecrlf true 允许提交包含混合换行符的文件 1git config --global core.safecrlf false 提交包含混合换行符的文件时给出警告 1git config --global core.safecrlf warn core.quotepath在使用git的时候，经常会碰到有一些中文文件名或者路径被转义成\xx\xx\xx之类的，此时可以通过git的配置来改变默认转义 1git config --global core.quotepath false core.pagercore.pager指定 Git 运行诸如log、diff等所使用的分页器，你能设置成用more或者任何你喜欢的分页器（默认用的是less）， 当然你也可以什么都不用，设置空字符串： 1git config --global core.pager '' 其它配置123456git config --global core.editor vim #设置文本编辑器git config --global color.ui truegit config --global alias.st status #设置别名git config receive.denyNonFastForwards true #禁止非快进试推送git config --global merge.tool kdiff3git config --global diff.word.textconv strings #在比较前把Word文件转换成文本文件 工作区 暂存区暂存区，又称为--stage或--index，是一个介于工作区和版本库的中间状态，当执行提交时，实际上是将暂存区的内容提交到版本库中。 版本库工作区/暂存区/版本库，三者的关系图 HEADHEAD是当前分支引用的指针，它总是指向该分支上的最后一次提交。这表示 HEAD将是下一次提交的父节点。通常，理解HEAD的最简方式，就是将它看做 你的上一次提交 的快照。符号^可以用于指代父提交 HEAD^代表版本库中的上一次提交，即最近一次提交的父提交HEAD^^则代表HEAD^的父提交对于一个提交有多个父提交，可以在符号^后面用数字表示是第几个父提交 查看快照1234567891011121314151617$ git cat-file -p HEADtree 684768932f4b16ef45aa5e87793a76470fb8becbparent ae1ffd161d1ffb564ba2a0e87dae45ec63ea5eeaauthor Jerry.Chen &lt;balabala@gmail.com&gt; 1453474460 +0800committer Jerry.Chen &lt;balabala@gmail.com&gt; 1453474460 +0800commit with -a``## 查看引用日志，是`HEAD`头指针的变迁记录，而非`master`分支```bash$ git reflogae1ffd1 HEAD@&#123;0&#125;: checkout: moving from b2 to master48c54d7 HEAD@&#123;1&#125;: checkout: moving from master to b2ae1ffd1 HEAD@&#123;2&#125;: checkout: moving from master to master 查看引用日志的输出123456789101112131415161718192021$ git show HEAD@&#123;0&#125;commit ae1ffd161d1ffb564ba2a0e87dae45ec63ea5eeaMerge: 3bce065 17ce0b6Author: Jerry &lt;jerry@china.com&gt;Date: Sun Apr 20 16:05:08 2014 +0800 merge ...diff --cc hello.mdindex 1e644f0,11f9129..70b7830--- a/hello.md+++ b/hello.md@@@ -6,7 -6,7 +6,8 @@@ 5 modify 6 modify by jerry 6 modify +7 modify by jerry+ 7 modify branch b1 1 modify branch b1 3 modify branch b1 2 modify branch b1 4 modify branch b2 1 modify SSH Key查看已经保存的SSH密钥1ls -lart ~/.ssh 生成SSH密钥1ssh-keygen -t rsa -C "your_email@example.com" 查看公钥（*.pub）文件的内容，如果没有修改密钥的位置和保存的路径，直接复制cat出来的内容，粘帖到你需要用到的地方 1cat ~/.ssh/id_rsa.pub git clone克隆操作，使用方法如下：1git clone [&lt;options&gt;] [--] &lt;repository&gt; [&lt;directory&gt;] 包含工作区的版本库在本地创建一个的克隆工作区，所有的文件都会检出，如果设置了[&lt;directory&gt;]，则会将此名称做为克隆的文件夹名称 1git clone &lt;repository&gt; [&lt;directory&gt;] 裸版本库，不包含工作区不包含工作区，直接就是版本库的内容，这样的版本库称为裸版本库。一般约定俗成裸版本库的目录名以.git为后缀，所以下面实例中将克隆出来的裸版本库目录名写作&lt;directory.git&gt; 12git clone --bare &lt;repository&gt; &lt;directory.git&gt;git clone --mirror &lt;repository&gt; &lt;directory.git&gt; git clone --mirror 克隆出来的裸版本对上游版本进行了注册，这样可以在裸版本库中使用git fetch命令和上游版本库进行持续同步 支持的多种协议常用的一些协议，不是全部 123456git clone file:///opt/git/project.gitgit clone /opt/git/project.gitgit clone ssh://user@server:project.gitgit clone http[s]://example.com/gitproject.gitgit clone git://example.com/path/to/repo.git/git clone git@github.com:User/progit.git git remote查看当前工作目录的远程仓库信息123git remote -vgit remote show #查看当前工作目录所有的远程仓库的简写名称git remote show [name] 123456789101112131415161718192021$ git remote -vorigin git@github.com:myoss/progit.git (fetch)origin git@github.com:myoss/progit.git (push)$ git remote showorigin$ git remote show origin* remote origin Fetch URL: git@github.com:myoss/progit.git Push URL: git@github.com:myoss/progit.git HEAD branch: master Remote branches: b1 tracked master tracked Local branches configured for 'git pull': b1 merges with remote b1 master merges with remote master Local refs configured for 'git push': b1 pushes to b1 (up to date) master pushes to master (up to date) 添加远程仓库1git remote add [name] [url] 修改远程仓库的url地址1git remote set-url &lt;name&gt; &lt;new_url&gt; 修改某个远程仓库的简写名称1git remote rename &lt;old_name&gt; &lt;new_name&gt; 移除某个远程仓库的配置信息，不会删除任何文件1git remote rm | remove &lt;name&gt; git fetch拉取远程仓库的更新数据只是将远端的数据拉到本地仓库，不会自动合并到当前工作分支。 12git fetch &lt;repository-name&gt; &lt;branch-name&gt; #repository-name：远程仓库的简写名称git fetch origin master 拉取所有远程仓库1git fetch --all git pull获取远程仓库的更新数据，再自动合并到本地仓库中的当前分支12git pull &lt;repository-name&gt; &lt;repository-branch-name&gt;git pull origin master 相当于做了以下2步操作，如果有冲突，将会合并失败 12git fetch origin mastergit merge origin/master 获取远程仓库的更新数据，再自动合并到本地仓库中的其它分支12git pull &lt;repository-name&gt; &lt;repository-branch-name&gt;:&lt;local-branch-name&gt;git pull origin master:dev #将远程仓库的master分支的更新，合并到本地的dev分支 获取远程仓库上所有的tag12git pull &lt;repository-name&gt; --tagsgit pull origin --tags git push将本地分支的更新，推送到远程仓库12git push &lt;repository-name&gt; &lt;local-branch-name&gt;:[repository-branch-name]git push origin local-dev:remote-dev #将本地的local-dev分支，推送到远程的remote-dev分支 通常的操作，省略掉远程分支名[repository-branch-name]，则表示将本地分支推送与之存在“追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。 123git push &lt;repository-name&gt; &lt;local-branch-name&gt;git push origin master #将本地的master分支推送到远程仓库的master分支git push origin b1 #如果远程仓库不存在b1分支，则会创建b1分支 删除远程仓库的分支第一种方式，如果省略[local-branch-name]，推送一个空的本地分支到远程分支，即删除掉[远程分支]，[本地分支]不会删除 1git push &lt;repository-name&gt; :&lt;repository-branch-name&gt; 示例：删除远程仓库的b3分支 123$ git push origin :b3To git@github.com:myoss/progit.git - [deleted] b3 第二种方式，使用--delete选项 1git push &lt;repository-name&gt; &lt;repository-branch-name&gt; --delete 示例：删除远程仓库的b2分支 123$ git push origin b2 --deleteTo git@github.com:myoss/progit.git - [deleted] b2 强制更新，覆盖的方式推送注意：此操作非常危险，因为能够将历史记录抹除掉，比如远程分支有3个提交：1，2，3，而本地分支有2个提交：4，5，并且和远程分支的提交不一样，如果强制推送了之后，远程分支上原来的3个提交就会丢失掉，变成和本地分支一样。总而言之，请三思而后行！！！ 强制更新，会在远程仓库产生一个“非块进式”的合并（non-fast-forward merge） 1git push &lt;repository-name&gt; &lt;local-branch-name&gt; -f | --force 操作注意： 在github中，通常会关闭对master分支的强制更新，关闭保护的步骤：在项目的Settings下的Branches中，找到Protected branches，将其关闭掉即可。 在gitlab中，通常会关闭对master分支的强制更新，关闭保护的步骤：在项目的Settings下，找到Protected branches，将其关闭掉即可。 推送标签默认情况下，git push并不会把标签推送到远程仓库，只有通过显式命令才能推送标签到远程仓库 1git push &lt;repository-name&gt; &lt;local-tag-name&gt; 推送所有的标签将本地所有的标签，推送到远程仓库（远程仓库没有的标签），注意是否有权限 1git push &lt;repository-name&gt; --tags 推送本地所有的分支，不包含标签1git push &lt;repository-name&gt; --all git init初始化本地仓库先在本地创建一个空目录，然后在创建的目录里使用git init初始化仓库 123$ mkdir my-work$ cd my-work$ git init 一步操作，仓库空目录，并初始化仓库 1$ git init my-work git add添加未跟踪的文件使用git add &lt;文件名1&gt;[,&lt;文件名2&gt;,&lt;文件名3&gt;]添加未跟踪的文件，这不会提交到本地仓库中。如需要提交，使用git commit -m &quot;提交的注释&quot; 123456789101112131415161718192021222324252627282930313233343536373839$ git status -s test.txt #查看精简状态，显示有一个未跟踪的文件?? test.txt$ git status #查看状态，现在有一个未跟踪的test.txt文件On branch masterYour branch is up-to-date with 'origin/master'.Untracked files: (use "git add &lt;file&gt;..." to include in what will be committed) test.txtnothing added to commit but untracked files present (use "git add" to track)$ git add test.txt #添加未跟踪的test.txt文件$ git status #再次查看状态，test.txt文件已经放到暂存区了On branch masterYour branch is up-to-date with 'origin/master'.Changes to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) new file: test.txt$ git status -s #查看精简状态，显示有一个添加的文件A test.txt$ git commit -m"添加文件：test.txt" #提交到本地git仓库中[master d14545d] 添加文件：test.txt 1 file changed, 1 insertion(+) create mode 100644 test.txt$ git status #再次查看状态，刚才添加的文件已经提交，并且领先远程仓库一个提交On branch masterYour branch is ahead of 'origin/master' by 1 commit. (use "git push" to publish your local commits)nothing to commit, working directory clean$ git status -s #查看精简状态，无内容 添加已经追踪的文件同样的使用git add &lt;文件名1&gt;[,&lt;文件名2&gt;,&lt;文件名3&gt;]添加已跟踪的文件，这不会提交到本地仓库中。如需要提交，使用git commit -m &quot;提交的注释&quot; 1234567891011121314151617181920212223242526272829303132333435363738394041$ git status #查看状态，有一个文件的内容修改了On branch masterYour branch is ahead of 'origin/master' by 1 commit. (use "git push" to publish your local commits)Changes not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: test.txtno changes added to commit (use "git add" and/or "git commit -a")$ git status -s #查看精简状态，显示有一个修改的文件，`M`字符的位置在第二列，颜色为红色 M test.txt$ git add test.txt #将test.txt文件修改的内容放到暂存区$ git status #再次查看状态，test.txt文件修改的内容已经放到暂存区了On branch masterYour branch is ahead of 'origin/master' by 1 commit. (use "git push" to publish your local commits)Changes to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: test.txt$ git status -s #查看精简状态，显示有一个修改的文件，`M`字符的位置在第一列，颜色为绿色M test.txt$ git commit -m"new update for test.txt" #提交到本地git仓库中[master 3a0f2d3] new update for test.txt 1 file changed, 1 insertion(+)$ git status #再次查看状态，刚才添加的文件已经提交，并且领先远程仓库两个提交On branch masterYour branch is ahead of 'origin/master' by 2 commits. (use "git push" to publish your local commits)nothing to commit, working directory clean$ git status -s #查看精简状态，无内容 巧用git add，快速回退测试代码假设已经开发好了某个功能，这时候用git add添加，但不做git commit 场景一：这时候我再去添加些测试代码测试，比如System.out.println这种代码，测试下来发现我刚才git add的代码都是OK的，这时候我用git checkout就能快速安全的删掉刚才添加的测试代码。场景二：我发现刚才git add的代码不够完美，修改完成之后，再次用git add添加，就会合并到上一次git add的代码中了，然后做为一次git commit。 git status查看当前分支的文件变化状态1git status 查看精简状态1git status -s M字符的位置在第二列，颜色为红色，表示工作区当前的文件与暂存区的文件相比有改动 12$ git status -s M test.txt M字符的位置在第一列，颜色为绿色，表示版本库中的文件与暂存区中的文件相比有改动 12$ git status -sM test.txt 同时显示所在的分支 12$ git status -sb## master...origin/master [ahead 2] git cherry查看本地分支领先远程仓库的提交123$ git cherry+ d14545d3754498d664caea7672761305b59dd162+ 3a0f2d351733ed9d234e6f0498bc533c11048686 git diff比较工作区和暂存区1git diff 逐词比较，而非默认的逐行比较1git diff --word-diff 比较暂存区和HEAD（本地git仓库）12git diff --cachedgit diff --staged 比较工作区和HEAD（本地git仓库）1git diff HEAD 比较两个提交用SHA-1值（前7位即可）比较两次提交之间的差异。注意顺序不一样，查看到的结果也会不一样。 1git diff &lt;$id1&gt; &lt;$id2&gt; 比较两个分支只比较已经提交的内容 1git diff &lt;branch1&gt; &lt;branch2&gt; 比较两个远程分支注意：可能需要先执行git fetch 1git diff pro/master pro/b1 当前分支比较另外一个分支1git diff &lt;branch2&gt; [current-branch] 比较之后，显示简要的增改行数统计123$ git diff --stat test.txt | 3 ++- 1 file changed, 2 insertions(+), 1 deletion(-) 比较二进制文件差异1git diff --binary git stash储藏当前工作区和暂存区修改的内容使用场景，当需要紧急处理一个bug时，工作区内容又没有完成，不适合提交，将未完成的修改保存到一个栈上，而你可以在任何时候重新应用这些改动。 1git stash 示例： 123$ git stashSaved working directory and index state WIP on master: ae1ffd1 merge ...HEAD is now at ae1ffd1 merge ... 储藏的完整命令1git stash [save [--patch] [-k|--[no-]keep-index] [-q|--quiet] [-u|--include-untracked] [-a|--all] [&lt;message&gt;] 如果需要在保存储藏的时候指定说明 1git stash save &lt;message&gt; 123$ git stash save "9 modify"Saved working directory and index state On master: 9 modifyHEAD is now at ae1ffd1 merge ... 使用参数--patch会显示工作区和HEAD的差异，通过对比差异文件的编辑决定在进度中最终要保存的工作的内容，通过编辑差异文件可以在进度中排除无关内容 1git stash --patch 12345678910111213141516171819202122232425262728293031323334353637$ git stash --patchdiff --git a/hello.md b/hello.mdindex 70b7830..d866fb0 100644--- a/hello.md+++ b/hello.md@@ -10,4 +10,7 @@ 7 modify branch b1 1 modify branch b1 3 modify branch b1 2 modify branch b1 4 modify+10 modify 1+10 modify 2+10 modify 3 branch b2 1 modifyStash this hunk [y,n,q,a,d,/,e,?]? ?y - stash this hunkn - do not stash this hunkq - quit; do not stash this hunk or any of the remaining onesa - stash this hunk and all later hunks in the filed - do not stash this hunk or any of the later hunks in the fileg - select a hunk to go to/ - search for a hunk matching the given regexj - leave this hunk undecided, see next undecided hunkJ - leave this hunk undecided, see next hunkk - leave this hunk undecided, see previous undecided hunkK - leave this hunk undecided, see previous hunks - split the current hunk into smaller hunkse - manually edit the current hunk? - print help@@ -10,4 +10,7 @@ 7 modify branch b1 1 modify branch b1 3 modify branch b1 2 modify branch b1 4 modify+10 modify 1+10 modify 2+10 modify 3 branch b2 1 modifyStash this hunk [y,n,q,a,d,/,e,?]? 使用-k或--keep-index参数，在保存进度后不将暂存区重置（默认会将暂存区和工作区强制重置，即命令：--no-keep-index的效果） 1git bash -k | --keep-index 1234567891011121314151617181920$ git status #当前暂存区有一个修改的文件On branch masterYour branch is up-to-date with 'origin/master'.Changes to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: hello.md$ git stash -k #储藏Saved working directory and index state WIP on master: ae1ffd1 merge ...HEAD is now at ae1ffd1 merge ...$ git status #储藏之后，暂存区修改的文件没有被清空On branch masterYour branch is up-to-date with 'origin/master'.Changes to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: hello.md 使用-u|--include-untracked，同时储藏未跟踪文件。 1git stash save -u|--include-untracked 使用-a|--all来储藏所有的改动，包括未跟踪文件 1git stash save -a|--all 查看已经保存的储藏列表123$ git stash liststash@&#123;0&#125;: On master: 9 modifystash@&#123;1&#125;: WIP on master: ae1ffd1 merge ... 删除储藏如果没有指定是第几个储藏时，默认会删除最近的一次储藏 1git stash drop [-q|--quiet] [&lt;stash@&#123;n&#125;&gt;] 12$ git stash drop stash@&#123;0&#125;Dropped stash@&#123;0&#125; (2fa94640f400006a6ba812b3c02e8b0e91472958) 删除所有的储藏1git stash clear 查看[某次]储藏修改的内容1git stash show [&lt;stash@&#123;n&#125;&gt;] 示例： 1234567$ git stash show #查看最后一次的储藏 hello.md | 2 ++ 1 file changed, 2 insertions(+)$ git stash show stash@&#123;1&#125; #查看某次的储藏 hello.md | 1 + 1 file changed, 1 insertion(+) 恢复保存的工作进度1git stash &lt;pop | apply&gt; [--index] [-q|--quiet] [&lt;stash@&#123;n&#125;&gt;] 如果不使用任何参数，恢复最近一次保存的工作进度 12git stash pop #会从储藏列表中删除刚刚恢复的暂存git stash apply #不会从储藏列表中删除刚刚恢复的暂存 如果使用&lt;stash@{n}&gt;参数，则从该&lt;stash@{n}&gt;中恢复保存的内容 12git stash pop &lt;stash@&#123;n&#125;&gt; #会从储藏列表中删除该`&lt;stash@&#123;n&#125;&gt;`git stash apply &lt;stash@&#123;n&#125;&gt; #不会从储藏列表中删除该`&lt;stash@&#123;n&#125;&gt;` --index除了恢复工作区的文件外，还会恢复暂存区的内容 12git stash pop --indexgit stash apply --index 使用储藏的内容创建新的分支&lt;branch-name&gt;不能是已经存在的分支，并切换到创建的新分支，删除掉该储藏 1git stash branch &lt;branch-name&gt; [&lt;stash@&#123;n&#125;&gt;] 123456789101112131415161718$ git stash branch b2Switched to a new branch 'b2'&lt;stdin&gt;:9: trailing whitespace.10 modify 2warning: 1 line adds whitespace errors.On branch b2Changes to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: hello.mdChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: hello.mdDropped refs/stash@&#123;0&#125; (3eaa4512757a598193acb1f9f0a7f91dc6c165b1) 查看储藏列表的SHA-1值123$ git reflog show refs/stash5afe096 refs/stash@&#123;0&#125;: On master: 9 modifya5c6080 refs/stash@&#123;1&#125;: WIP on master: ae1ffd1 merge ... git commit仓库中的文件可能存在于这三种状态 Untracked files → 文件未被跟踪 Changes to be committed → 文件已暂存，这是下次提交的内容 Changes not staged for commit → 文件被修改，但并没有添加到暂存区。如果commit时没有带-a选项，此状态下的文件不会被提交。 1234567891011121314151617$ git statusOn branch b2Changes to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: hello.mdChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: hello.mdUntracked files: (use "git add &lt;file&gt;..." to include in what will be committed) test.txt 提交暂存区的内容提交状态为Changes to be committed的内容 1git commit [-m &lt;message&gt;] 提交暂存区和工作区的内容提交状态为Changes to be committed和Changes not staged for commit的内容 1git commit -a [-m &lt;message&gt;] 12345678910111213141516171819202122232425262728$ git statusOn branch b2Changes to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: hello.mdChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: hello.mdUntracked files: (use "git add &lt;file&gt;..." to include in what will be committed) test.txt$ git commit -a -m"commit with -a"[b2 48c54d7] commit with -a 1 file changed, 3 insertions(+)$ git statusOn branch b2Untracked files: (use "git add &lt;file&gt;..." to include in what will be committed) test.txt 修改或者撤销最后一次提交12git commit --amend #进入交互终端模式git commit --amend -m &lt;message&gt; #修改最后一次提交的注释 修改最后一次提交，退出编辑器之后会直接commit。如果要取消，则在编辑器里清空掉提交信息再退出即可。使用场景如：修改提交信息、补正刚才修改的内容（需要先git add）、少添加文件了（需要先git add），谨慎操作！！ git checkout汇总显示（工作区和暂存区）与HEAD的差异12git checkout [HEAD]git checkout HEAD 1234567891011121314151617181920212223242526$ git statusOn branch b2Changes to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: hello.mdChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: README.mdUntracked files: (use "git add &lt;file&gt;..." to include in what will be committed) test.txt$ git checkout #不会统计未追踪的文件M README.mdM hello.md$ git checkout HEADM README.mdM hello.md 撤销工作区的修改用暂存区中的内容覆盖工作区的内容，如果使用.，而没有指定具体的file，会替换工作区所有有改动的文件 1git checkout [--] &lt;. | file&gt; 1234567891011121314151617181920212223242526272829303132$ git statusOn branch b2Changes to be committed: #暂存区的修改 (use "git reset HEAD &lt;file&gt;..." to unstage) modified: hello.mdChanges not staged for commit: #工作区的修改 (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: hello.mdUntracked files: (use "git add &lt;file&gt;..." to include in what will be committed) test.txt$ git checkout hello.md #使用暂存区的内容覆盖工作区的内容$ git status #工作区没有修改的内容On branch b2Changes to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: hello.mdUntracked files: (use "git add &lt;file&gt;..." to include in what will be committed) test.txt 用HEAD中的内容替换暂存区和工作区的修改取出最近的一次提交的内容，替换暂存区和工作区的修改，如果使用.，而没有指定具体的file，会替换暂存区和工作区中所有有改动的文件 123git checkout [--] &lt;. | file&gt;git checkout &lt;file&gt;git checkout . 1234567891011121314151617181920212223242526272829$ git status #暂存区和工作区都有修改On branch masterYour branch is up-to-date with 'origin/master'.Changes to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: hello.mdChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: hello.mdUntracked files: (use "git add &lt;file&gt;..." to include in what will be committed) test.txt$ git checkout HEAD hello.md #撤销暂存区和工作区的修改$ git status #hello.md在暂存区和工作区没有修改On branch masterYour branch is up-to-date with 'origin/master'.Untracked files: (use "git add &lt;file&gt;..." to include in what will be committed) test.txt 使用其它分支的内容替换当前分支上暂存区和工作区的内容HEAD的指向不会变化 1git checkout &lt;branch-name&gt; [--] &lt;file&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778Administrator@Jerry-WIN8-TP MINGW64 /d/workspaces/test/progit (master)$ git status #当前分支是：master，hello.md在暂存区和工作区都有修改On branch masterYour branch is up-to-date with 'origin/master'.Changes to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: hello.mdChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: hello.mdUntracked files: (use "git add &lt;file&gt;..." to include in what will be committed) test.txtAdministrator@Jerry-WIN8-TP MINGW64 /d/workspaces/test/progit (master)$ git diff b2 #master分支和b2分支比较hello.md的内容diff --git a/hello.md b/hello.mdindex d866fb0..44d3964 100644--- a/hello.md+++ b/hello.md@@ -8,9 +8,8 @@ 6 modify 7 modify by jerry 7 modify+8 modify^M #master分支上的内容 branch b1 1 modify branch b1 3 modify branch b1 2 modify branch b1 4 modify-10 modify 1 #b2分支上的内容-10 modify 2-10 modify 3+master modify 11^M branch b2 1 modifyAdministrator@Jerry-WIN8-TP MINGW64 /d/workspaces/test/progit (master)$ git checkout b2 hello.md #用b2分支上hello.md的内容替换暂存区和工作区的内容Administrator@Jerry-WIN8-TP MINGW64 /d/workspaces/test/progit (master)$ git diff b2 #master分支和b2分支没有差异Administrator@Jerry-WIN8-TP MINGW64 /d/workspaces/test/progit (master)$ git status #暂存区还是有hello.md这个文件On branch masterYour branch is up-to-date with 'origin/master'.Changes to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: hello.mdUntracked files: (use "git add &lt;file&gt;..." to include in what will be committed) test.txtAdministrator@Jerry-WIN8-TP MINGW64 /d/workspaces/test/progit (master)$ cat hello.md #查看master分支上hello.md文件内容，发现b2分支的内容替换过来了6 modify1 add2 modify3 modify4 mdofiy --&gt; amend 35 modify6 modify by jerry6 modify7 modify by jerry7 modifybranch b1 1 modify branch b1 3 modifybranch b1 2 modify branch b1 4 modify10 modify 1 #这3行是b2分支上添加的内容，现在出现在master分支上了10 modify 210 modify 3branch b2 1 modify git reset基本操作将当前的分支重设（reset）到指定的&lt;commit&gt;或者HEAD（如果不显示指定commit，默认是HEAD，即最新的一次提交），并且根据选项有可能更新暂存区和工作区 1git reset [--mixed | --soft | --hard | --merge | --keep] [-q] [&lt;commit&gt;] --soft：暂存区和工作区中的内容不作任何改变，仅仅把HEAD指向&lt;commit&gt;。这个模式的效果是，执行完毕后，自从&lt;commit&gt;以来的所有改变都会显示为Changes to be committed（git status） 。不会丢失任何改动 123git reset --soft &lt;commit&gt;git reset --soft HEAD^ #HEAD^代表版本库中的最近一次提交的父提交，即重置到倒数第二次提交 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475$ git hist #现在有3个提交* adba38b v3 commit* c7ded78 v2 commit* 45496b8 v1 commit$ cat readme.md #文件的内容如下v1v2v3v4$ git status #工作区有修改的内容，暂存区没有修改的内容On branch masterChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: readme.md$ git diff #比较工作区和暂存区diff --git a/readme.md b/readme.mdindex 4b1d4d4..ed7ce12 100644--- a/readme.md+++ b/readme.md@@ -1,3 +1,4 @@ v1 v2 v3+v4 #工作区修改的内容$ git reset --soft c7ded78 #将分支重设到第二次提交$ git status #查看状态，暂存区显示有待提交的内容On branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: readme.mdChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: readme.md$ git diff #比较工作区和暂存区，工作区的内容还是之前的diff --git a/readme.md b/readme.mdindex 4b1d4d4..ed7ce12 100644--- a/readme.md+++ b/readme.md@@ -1,3 +1,4 @@ v1 v2 v3+v4$ git diff --cached HEAD #比较暂存区和HEAD的差异diff --git a/readme.md b/readme.mdindex 2139d8b..4b1d4d4 100644--- a/readme.md+++ b/readme.md@@ -1,2 +1,3 @@ v1 v2+v3 #这一行就是第三次提交的内容$ git hist #查看提交日志* c7ded78 v2 commit* 45496b8 v1 commit$ cat readme.mdv1v2v3v4 --hard：重设暂存区和工作区，自从&lt;commit&gt;以来在工作区中的任何改变都被丢弃，并把HEAD指向&lt;commit&gt;。会丢失改动 12345git reset --hard &lt;commit&gt;git reset --hard HEAD^ #HEAD^代表版本库中的最近一次提交的父提交，即丢弃掉最近的一次提交git reset --hard origin/master #丢弃在本地的所有改动与提交，用远程仓库的提交覆盖 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061$ git hist #现在有3个提交* adba38b v3 commit* c7ded78 v2 commit* 45496b8 v1 commit$ cat readme.md #文件的内容如下v1v2v3v4v5$ git diff #比较工作区和暂存区diff --git a/readme.md b/readme.mdindex ed7ce12..4d73d61 100644--- a/readme.md+++ b/readme.md@@ -2,3 +2,4 @@ v1 v2 v3 v4+v5 #工作区修改的内容$ git diff --cached HEAD #比较暂存区和HEAD的差异diff --git a/readme.md b/readme.mdindex 4b1d4d4..ed7ce12 100644--- a/readme.md+++ b/readme.md@@ -1,3 +1,4 @@ v1 v2 v3+v4 #暂存区修改的内容$ git status #查看状态，工作区和暂存区显示有修改的内容On branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: readme.mdChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: readme.md$ git reset --hard c7ded78 #将分支重设到第二次提交HEAD is now at c7ded78 v2 commit$ git status #查看状态，工作区和暂存区显示没有修改的内容On branch masternothing to commit, working directory clean$ git hist #查看提交日志* c7ded78 v2 commit* 45496b8 v1 commit$ cat readme.md #查看文件的内容，重设前的工作区和暂存区修改的内容已经丢失掉了v1v2 --mixed：仅重设暂存区，但是不重设工作区。这个模式是默认模式，即当不显示告知git reset模式时，会使用--mixed模式。这个模式的效果是，工作区中文件的修改都会被保留，不会丢弃，但是也不会被标记成Changes to be committed。不会丢失任何改动 12git reset &lt;commit&gt;git reset --mixed &lt;commit&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283$ git hist #现在有3个提交* adba38b v3 commit* c7ded78 v2 commit* 45496b8 v1 commit$ cat readme.md #文件的内容如下v1v2v3v4v5$ git diff #比较工作区和暂存区diff --git a/readme.md b/readme.mdindex ed7ce12..4d73d61 100644--- a/readme.md+++ b/readme.md@@ -2,3 +2,4 @@ v1 v2 v3 v4+v5 #工作区修改的内容$ git diff --cached HEAD #比较暂存区和HEAD的差异diff --git a/readme.md b/readme.mdindex 4b1d4d4..ed7ce12 100644--- a/readme.md+++ b/readme.md@@ -1,3 +1,4 @@ v1 v2 v3+v4 #暂存区修改的内容$ git status #查看状态，工作区和暂存区显示有修改的内容On branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: readme.mdChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: readme.md$ git reset --mixed c7ded78 #将分支重设到第二次提交Unstaged changes after reset:M readme.md$ git status #查看状态，暂存区没有待提交的内容On branch masterChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: readme.mdno changes added to commit (use "git add" and/or "git commit -a")$ git diff #比较工作区和暂存区diff --git a/readme.md b/readme.mdindex 2139d8b..4d73d61 100644--- a/readme.md+++ b/readme.md@@ -1,2 +1,5 @@ v1 v2+v3 #重设前HEAD的内容，出现在工作区了+v4 #重设前暂存区的内容，出现在工作区了+v5 #重设前工作区的内容$ git hist #查看提交日志* c7ded78 v2 commit* 45496b8 v1 commit$ cat readme.md #查看文件的内容，重设前的工作区和暂存区修改的内容没有丢失掉了v1v2v3v4v5 重置暂存区将暂存区添加的内容，回退到工作区，改动不会丢失。如果指定了文件&lt;file&gt;，则只处理此文件 123456git reset HEADgit reset --git resetgit reset HEAD &lt;file&gt;git reset -- &lt;file&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758$ git hist #现在有3个提交* adba38b v3 commit* c7ded78 v2 commit* 45496b8 v1 commit$ git status #查看状态，暂存区显示有修改的内容On branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: readme.md new file: test.md$ git diff$ git diff --cached #比较工作区和暂存区diff --git a/readme.md b/readme.mdindex 4b1d4d4..0d6160d 100644--- a/readme.md+++ b/readme.md@@ -1,3 +1,4 @@ v1 v2 v3+v4diff --git a/test.md b/test.mdnew file mode 100644index 0000000..e69de29$ git reset HEAD #重置暂存区Unstaged changes after reset:M readme.md$ git status #查看状态，刚才在暂存区待提交的内容已经退回到工作区On branch masterChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: readme.mdUntracked files: (use "git add &lt;file&gt;..." to include in what will be committed) test.mdno changes added to commit (use "git add" and/or "git commit -a")$ git diffdiff --git a/readme.md b/readme.mdindex 4b1d4d4..0d6160d 100644--- a/readme.md+++ b/readme.md@@ -1,3 +1,4 @@ v1 v2 v3+v4 实战：两个提交压缩为一个使用--soft参数调用重置命令，回到最近两次提交之前 1git reset --soft HEAD^^ 查看版本状态和最新日志，如果需要修改就进行修改 执行提交操作，即完成最新两个提交压缩为一个 1git commit -m"Message" git rebase交互式变基操作&lt;since&gt;和&lt;till&gt;代表历史提交的SHA-1值，变基的范围是从&lt;since&gt;（不包括&lt;since&gt;）的下一个提交到&lt;till&gt;，如果&lt;till&gt;没有给出，则变基的范围到当前HEAD。 1git rebase -i &lt;since&gt; [&lt;till&gt;] 12345678910111213141516171819202122232425262728293031$ git hist #现在有5个提交* 1c1e018 v5 commit* 45d9dfb v4 commit* adba38b v3 commit* c7ded78 v2 commit* 45496b8 v1 commit$ git rebase -i c7ded78 45d9dfb #变基范围为第三个提交到第四个提交#稍等一会儿，就会弹出交互式界面，如果范围比较长需要等待的时间会久一些，如下：pick adba38b v3 commitpick 45d9dfb v4 commit# Rebase c7ded78..45d9dfb onto c7ded78 (2 command(s)) #能够操作的提交只有2个## Commands:# p, pick = use commit# r, reword = use commit, but edit the commit message# e, edit = use commit, but stop for amending# s, squash = use commit, but meld into previous commit# f, fixup = like "squash", but discard this commit's log message# x, exec = run command (the rest of the line) using shell# d, drop = remove commit## These lines can be re-ordered; they are executed from top to bottom.## If you remove a line here THAT COMMIT WILL BE LOST.## However, if you remove everything, the rebase will be aborted.## Note that empty commits are commented out 开头的几行由上到下依次对应历史的提交，如果删除掉这些提交保存退出交互式模式，则不执行变基动作 pick，或简写p，默认的动作，即应用此提交 reword，或简写r。在变基时会应用此提交，但是在提交的时候允许用户修改提交说明 edit，或简写e。在变基时会应用此提交，但是在应用后你可以进行内容编辑，需要使用git commit --amend执行提交，以便对提交进行修补。当用户执行git commit --amend完成提交后，还需要执行git rebase --continue继续变基操作。用户在变基暂停状态下可以执行多次提交，从而实现把一个提交分解为多个提交 squash，简写s。该提交会与前面的提交压缩为一个 fixup，简写f。类似动作squash，但是提交的提交说明被丢弃 可以通过修改变基任务文件中各个提交的先后顺序，进而改变最终变基后提交的先后顺序 可以通过改变变基任务文件，删除包含相应提交的行，这样该提交就不会被应用，进而在变基后的提交中被删除 在变基遇到冲突而暂停的情况下，先完成冲突解决（添加到暂存区，不提交），然后在恢复变基操作的时候使用该命令 1git rebase --continue 在变基遇到冲突而暂停的情况下，跳过当前提交的时候使用，谨慎用 1git rebase –abort 在变基遇到冲突而暂停的情况下，终止变基操作，回到之前的分支时候使用 1git rebase –skip 将其它分支上的修改应用到当前分支将远程仓库的更新，合并到当前分支上产生一个新的提交，如果工作区或者暂存区有未提交的更改，变基动作不会执行 12git fetch origin mastergit rebase origin/master git branch显示所有分支信息12git branchgit branch -v 1234567$ git branch #显示所有分支名称 b1* master$ git branch -v #显示所有分支名称，同时显示最后的提交注释，*：代表当前分支 b1 45d9dfb v4 commit* master 1c1e018 v5 commit 创建新分支创建新分支之后，不会自动切换到新分支上 1git branch &lt;new-branch-name&gt; 基于&lt;commit&gt;创建新分支，不会自动切换到新分支上 1git branch &lt;new-branch-name&gt; &lt;commit&gt; 使用git checkout创建新分支，并自动切换到这个分支上 1git checkout -b &lt;new-branch-name&gt; 使用git checkout基于标签创建新分支，并自动切换到这个分支上 1git checkout -b &lt;new-branch-name&gt; &lt;tag-name&gt; 使用git checkout基于标签创建新分支，没有指定&lt;new-branch-name&gt;，HEAD会进入到游离指针状态 1git checkout -b &lt;tag-name&gt; 12345678910111213$ git checkout v5Note: checking out 'v5'.You are in 'detached HEAD' state. You can look around, make experimentalchanges and commit them, and you can discard any commits you make in thisstate without impacting any branches by performing another checkout.If you want to create a new branch to retain commits you create, you maydo so (now or later) by using -b with the checkout command again. Example: git checkout -b &lt;new-branch-name&gt;HEAD is now at 1c1e018... v5 commit 退出游离指针状态 12git checkout &lt;branch-name&gt; #切换到其它分支git checkout -b &lt;new-branch-name&gt; #将游离指针状态，切换到创建的新分支上 创建新分支来跟踪远程分支，并自动切换到这个分支上 1git checkout -b &lt;new-branch-name&gt; &lt;remote-name&gt;/&lt;remote-branch-name&gt; 重命名分支如果&lt;new-branch-name&gt;已经存在，重命名动作停止 1git branch -m &lt;old-branch-name&gt; &lt;new-branch-name&gt; 如果&lt;new-branch-name&gt;已经存在，重命名动作继续，请谨慎操作 1git branch -M &lt;old-branch-name&gt; &lt;new-branch-name&gt; 12345678910111213$ git branch -v b1 1c1e018 v5 commit b2 1c1e018 v5 commit* master 1c1e018 v5 commit$ git branch -m b2 b1fatal: A branch named 'b1' already exists.$ git branch -M b2 b1$ git branch -v b1 1c1e018 v5 commit* master 1c1e018 v5 commit 删除分支如果分支上存在未被合并的提交，删除动作停止 1git branch -d &lt;branch-name&gt; 如果分支上存在未被合并的提交，删除动作继续，请谨慎操作 1git branch -D &lt;branch-name&gt; 12345678910111213$ git branch -v b1 2e6423e v6 commit on branch b1* master 1c1e018 v5 commit$ git branch -d b1 #提示b1分支上存在没有被合并的提交error: The branch 'b1' is not fully merged.If you are sure you want to delete it, run 'git branch -D b1'.$ git branch -D b1Deleted branch b1 (was 2e6423e).$ git branch -v* master 1c1e018 v5 commit 查看已经合并到当前分支的分支1git branch --merged 查看没有合并到当前分支的分支1git branch --no-merged 1234567891011$ git branch -v b1 1c1e018 v5 commit b2 82fa977 v6 commit* master 1c1e018 v5 commit$ git branch --merged b1* master$ git branch --no-merged b2 git merge有未提交修改情况下，不要执行merge！遵守这条警告，防患于未然 基本操作1git merge [&lt;options&gt;] [&lt;commit&gt;...] 默认合并成功后会自动提交，使用--no-commit选项，则合并后的内容会放入暂存区，需要手动提交 &lt;commit&gt;可以是提交的SHA-1值、分支、标签等 &lt;commit&gt;如果是多个提交，合并成功后，当前HEAD是第一个&lt;commit&gt;的父提交，第一个&lt;commit&gt;是第二个&lt;commit&gt;的父提交，依次类推 123456789101112131415161718192021222324252627282930$ git hist b2 #b2分支上有7个提交，领先master分支2个提交* ece4a12 v7 commit* 82fa977 v6 commit* 1c1e018 v5 commit* 45d9dfb v4 commit* adba38b v3 commit* c7ded78 v2 commit* 45496b8 v1 commit$ git hist master #master分支上有5个提交* 1c1e018 v5 commit* 45d9dfb v4 commit* adba38b v3 commit* c7ded78 v2 commit* 45496b8 v1 commit$ git merge 82fa977 ece4a12 #合并b2分支上的2个提交Updating 1c1e018..ece4a12Fast-forward readme.md | 2 ++ 1 file changed, 2 insertions(+)$ git hist master* ece4a12 v7 commit* 82fa977 v6 commit* 1c1e018 v5 commit* 45d9dfb v4 commit* adba38b v3 commit* c7ded78 v2 commit* 45496b8 v1 commit 不要Fast-Foward合并，会生成merge提交信息1git merge [&lt;commit&gt;...] --no-ff 不要Fast-Foward合并，手动生成merge提交信息 1git merge [&lt;commit&gt;...] --no-ff -m"&lt;Message&gt;" 123456789101112131415$ git merge 82fa977 --no-ffMerge made by the 'recursive' strategy. readme.md | 1 + 1 file changed, 1 insertion(+)$ git hist* 2cc5c4c Merge commit '82fa977'|\| * 82fa977 v6 commit|/* 1c1e018 v5 commit* 45d9dfb v4 commit* adba38b v3 commit* c7ded78 v2 commit* 45496b8 v1 commit 将分支合并到当前分支1git merge &lt;branch&gt; 终止合并操作冲突时执行中止merge操作，merge manual中说，这条命令会尽力恢复到Merge之前的状态（可能失败！） 1git merge --abort git tag创建轻量级标签轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。如果只是临时性加注标签，或者不需要旁注额外信息，用轻量级标签也没问题 1git tag &lt;new-tag-name&gt; 1$ git tag v1.0.0 #创建一个标签 创建含附注标签含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用GNU Privacy Guard (GPG)来签署或验证。一般我们都建议使用含附注型的标签，以便保留相关信息。 1git tag -a &lt;new-tag-name&gt; -m "&lt;Message&gt;" 如果有自己的GPG私钥，还可以用GPG来签署标签，只需要把之前的-a改为-s 1git tag -s &lt;new-tag-name&gt; -m "&lt;Message&gt;" GPG签署工作首先，在开始签名之前你需要先配置GPG并安装个人密钥。 123456$ gpg --list-keys/Users/schacon/.gnupg/pubring.gpg---------------------------------pub 2048R/0A46826A 2014-06-04uid Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;sub 2048R/874529A9 2014-06-04 如果你还没有安装一个密钥，可以使用gpg --gen-key生成一个。 1gpg --gen-key 一旦你有一个可以签署的私钥，可以通过设置Git的user.signingkey选项来签署。 1git config --global user.signingkey 0A46826A 如果已经设置好一个GPG私钥，可以使用它来签署新的标签。所有需要做的只是使用-s代替-a即可： 1$ git tag -s v1.5 -m 'my signed 1.5 tag' 如果在那个标签上运行git show，会看到你的GPG签名附属在后面： 1234567891011121314151617181920212223$ git show v1.5tag v1.5Tagger: Ben Straub &lt;ben@straub.cc&gt;Date: Sat May 3 20:29:41 2014 -0700my signed 1.5 tag-----BEGIN PGP SIGNATURE-----Version: GnuPG v1iQEcBAABAgAGBQJTZbQlAAoJEF0+sviABDDrZbQH/09PfE51KPVPlanr6q1v4/UtLQxfojUWiLQdg2ESJItkcuweYg+kc3HCyFejeDIBw9dpXt00rY26p05qrpnG+85bhM1/PswpPLuBSr+oCIDj5GMC2r2iEKsfv2fJbNW8iWAXVLoWZRF8B0MfqX/YTMbmecorc4iXzQu7tupRihslbNkfvfciMnSDeSvzCpWAHl7h8Wj6hhqePmLm9lAYqnKp8S5B/1SSQuEAjRZgI4IexpZoeKGVDptPHxLLS38fozsyi0QyDyzEgJxcJQVMXxViRUysgqjcpT8+iQM1PblGfHR4XAhuOqN5Fx06PSaFZhqvWFezJ28/CLyX5q+oIVk==EFTF-----END PGP SIGNATURE-----commit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date: Mon Mar 17 21:52:11 2008 -0700 changed the version number 要验证一个签署的标签，可以运行git tag -v [tag-name]。这个命令使用GPG来验证签名。为了验证能正常工作，签署者的公钥需要在你的钥匙链中。 12345678910111213$ git tag -v v1.4.2.1object 883653babd8ee7ea23e6a5c392bb739348b1eb61type committag v1.4.2.1tagger Junio C Hamano &lt;junkio@cox.net&gt; 1158138501 -0700GIT 1.4.2.1Minor fixes since 1.4.2, including git-mv and git-http with alternates.gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9Agpg: Good signature from "Junio C Hamano &lt;junkio@cox.net&gt;"gpg: aka "[jpeg image of size 1513]"Primary key fingerprint: 3565 2A26 2040 E066 C9A7 4A7D C0C6 D9A4 F311 9B9A 如果没有签署者的公钥，那么你将会得到类似下面的东西： 123gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9Agpg: Can't check signature: public key not founderror: could not verify the tag 'v1.4.2.1' 在最新版本的Git中（v1.7.9及以上），也可以签署个人提交。 如果相对于标签而言你对直接签署到提交更感兴趣的话，所有要做的只是增加一个-S到git commit命令。 12345678910$ git commit -a -S -m 'signed commit'You need a passphrase to unlock the secret key foruser: "Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;"2048-bit RSA key, ID 0A46826A, created 2014-06-04[master 5c3386c] signed commit 4 files changed, 4 insertions(+), 24 deletions(-) rewrite Rakefile (100%) create mode 100644 lib/git.rb git log也有一个--show-signature选项来查看及验证这些签名。 12345678$ git log --show-signature -1commit 5c3386cf54bba0a33a32da706aa52bc0155503c2gpg: Signature made Wed Jun 4 19:49:17 2014 PDT using RSA key ID 0A46826Agpg: Good signature from "Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;"Author: Scott Chacon &lt;schacon@gmail.com&gt;Date: Wed Jun 4 19:49:17 2014 -0700 signed commit 查看所有的标签123git taggit tag -lgit tag --list 1234567891011$ git tagv1.0.0v2.0.0$ git tag -lv1.0.0v2.0.0$ git tag --listv1.0.0v2.0.0 标签匹配查询使用*支持模糊匹配 1git tag -l | --list "tag-name*" 12$ git tag -l "*1*"v1.0.0 查看标签的信息1git tag show &lt;tag-name&gt; 删除标签1git tag -d &lt;tag-name&gt; 文件内容追溯追溯整个文件的内容会逐行显示文件，在每一行的行首显示此行最早是在什么版本引入的，由谁引入的 1git blame &lt;file&gt; 1234567$ git blame readme.md^45496b8 (Jerry.Chen 2016-01-23 18:46:54 +0800 1) v1c7ded782 (Jerry.Chen 2016-01-23 18:47:08 +0800 2) v2adba38bc (Jerry.Chen 2016-01-23 18:47:35 +0800 3) v345d9dfb1 (Jerry.Chen 2016-01-23 21:52:08 +0800 4) v41c1e0188 (Jerry.Chen 2016-01-23 22:13:49 +0800 5) v582fa9774 (Jerry.Chen 2016-01-23 23:37:39 +0800 6) v6 追溯指定的行号n：起始行号；m：结束行号，如果未指定，则使用文件的最后一行的行号 1git blame -L &lt;n[,m]&gt; &lt;file&gt; 123456789$ git blame readme.md -L 3adba38bc (Jerry.Chen 2016-01-23 18:47:35 +0800 3) v345d9dfb1 (Jerry.Chen 2016-01-23 21:52:08 +0800 4) v41c1e0188 (Jerry.Chen 2016-01-23 22:13:49 +0800 5) v582fa9774 (Jerry.Chen 2016-01-23 23:37:39 +0800 6) v6$ git blame readme.md -L 3,4adba38bc (Jerry.Chen 2016-01-23 18:47:35 +0800 3) v345d9dfb1 (Jerry.Chen 2016-01-23 21:52:08 +0800 4) v4 git ls-files显示暂存区和版本库中的文件1git ls-files 查看历史版本的文件列表1git ls-files --with-tree=HEAD^ git rm工作区删除文件1git rm &lt;file&gt; 123456789$ git rm readme.mdrm 'readme.md'$ git statusOn branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) deleted: readme.md 暂存区删除文件从暂存区删除文件，工作区不会删除。删除的文件在工作区存在，状态变为未追踪 1git rm --cached &lt;file&gt; 1234567891011121314$ git rm --cached readme.mdrm 'readme.md'$ git statusOn branch masterChanges to be committed: #暂存区有待提交的删除内容 (use "git reset HEAD &lt;file&gt;..." to unstage) deleted: readme.mdUntracked files: #删除的文件在工作区存在，状态变为未追踪 (use "git add &lt;file&gt;..." to include in what will be committed) readme.md git clean显示将要被删除的目录和文件针对那些未被跟踪的文件和目录 1git clean -nd 删除掉未被跟踪的文件和目录1git clean -fd git mv移动或者重命名文件如果移动或者重命名文件操作成功会添加到暂存区 1git mv [&lt;options&gt;] &lt;source&gt;... &lt;destination&gt; -n | --dry-run：演练移动或者重命名文件，看看操作是否会成功 1git mv -n | --dry-run &lt;source&gt;... &lt;destination&gt; 1234567$ git mv readme.md t1.md -n #演练将readme.md重命名为t1.mdChecking rename of 'readme.md' to 't1.md'Renaming readme.md to t1.md$ git status #查看状态，没有修改的内容On branch masternothing to commit, working directory clean -f | --force：强制移动或者重命名文件，不管目标是否已经存在 1git mv -f | --force &lt;source&gt;... &lt;destination&gt; git log12345678910111213141516171819202122232425262728293031323334353637383940git log 显示提交历史信息git log &lt;branch&gt; 显示分支提交历史信息git log -(n) 仅显示最近的n条提交git log &lt;file&gt; 显示该文件提交信息 git log -p 显示每次提交的内容差异 git log -p -2 仅显示最近的两次更新 git log --stat 显示简要的增改行数统计git log --date-order --date=iso --graph --full-history --all --pretty=format:'%x08%x09%C(red)%h %C(cyan)%ad%x08%x08%x08%x08%x08%x08%x08%x08%x08%x08%x08%x08%x08%x08%x08 %C(bold blue)%aN%C(reset)%C(bold yellow)%d %C(reset)%s' -p 按补丁格式显示每个更新之间的差异。 --stat 显示每次更新的文件修改统计信息。 --shortstat 只显示--stat 中最后的行数修改添加移除统计。 --name-only 仅在提交信息后显示已修改的文件清单。 --name-status 显示新增、修改、删除的文件清单。 --abbrev-commit 仅显示SHA-1 的前几个字符，而非所有的40 个字符。 --relative-date 使用较短的相对时间显示（比如，“2 weeks ago”）。 --graph 显示ASCII 图形表示的分支合并历史。 --pretty 使用其他格式显示历史提交信息。可用的选项包括oneline，short，full，fuller 和format（后跟指定格式）。 format选项说明 %H 提交对象（commit）的完整哈希字串 %h 提交对象的简短哈希字串 %T 树对象（tree）的完整哈希字串 %t 树对象的简短哈希字串 %P 父对象（parent）的完整哈希字串 %p 父对象的简短哈希字串 %an 作者（author）的名字 %ae 作者的电子邮件地址 %ad 作者修订日期（可以用-date= 选项定制格式） %ar 作者修订日期，按多久以前的方式显示 %cn 提交者(committer)的名字 %ce 提交者的电子邮件地址 %cd 提交日期 %cr 提交日期，按多久以前的方式显示 %s 提交说明git log --pretty="%h:%s" --author=gitster --since="2008-10-01" --before="2008-11-01" --no-merges--since, --after 仅显示指定时间之后的提交。--until, --before 仅显示指定时间之前的提交。--author 仅显示指定作者相关的提交。--committer 仅显示指定提交者相关的提交。git log --oneline --decorate 显示tag信息 忽略文件工作区创建文件.gitignore工作区创建文件.gitignore，然后在里面添加忽略规则。.gitignore这个文件本身会提交到版本库中去，用来保存的是公共的需要排除的文件。.gitignore的语法规范如下： 以＃开头的行是注释 以/做为行尾字符，则要忽略的是目录 以!做为行首字符，则是取反模式 空白行不做处理 支持正则表达模式匹配* 匹配零个或多个任意字符[abc] 匹配任何一个在方括号中的字符? 匹配任意一个字符[0-9a-zA-Z] 在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如[0-9a-zA-Z]表示匹配所有0到9的数字和所有字母）\ 转义字符[ ^abc] 匹配不是a, b, c中任一字符即可{ab,bb,cx} 匹配ab, bb, cx中任一类型即可 123456789101112$ touch .gitignore$ ls -a./ ../ .git/ .gitignore readme.md$ vi .gitignore.a # 忽略所有 .a 结尾的文件!lib.a # 但 lib.a 除外/TODO # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODObuild/ # 忽略 build/ 目录下的所有文件doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt 注意：.gitignore只能忽略那些没有被版本库追踪的文件，如果文件已经提交到了版本管理中，则在.gitignore中对这些文件的忽略是无效的，可以使用以下方式进行临时忽略 12git update-index --assume-unchanged /path/to/file #忽略跟踪git update-index --no-assume-unchanged /path/to/file #恢复跟踪 但此方式在git rebase操作之后，这些被忽略的文件内容如果被修改过了，会被强制恢复到git rebase这个时候的版本内容。如果要从根本上忽略这些文件，请使用git rm删除掉这些文件，然后提交到版本库中 编辑.git/info/exclude独享忽略列表，不需要提交到版本库中，不会影响其他人 1$ vi .git/info/exclude 用户目录下的全局.gitignore在用户目录下创建~/.gitignore文件，以同样的规则来添加哪些文件是不需要版本控制的 1git config --global core.excludesfile ~/.gitignore #需要执行此命令，才能是全局配置生效 git grep操作语法1git grep [&lt;options&gt;] [-e] &lt;pattern&gt; [&lt;rev&gt;...] [[--] &lt;path&gt;...] 1git grep "工作区文件内容搜索" windows平台下的msysGit中shell环境配置编辑配置文件/etc/inputrc，修改或者添加以下配置，重启后就能在shell界面输入中文 12345# disable/enable 8bit inputset meta-flag onset input-meta onset output-meta onset convert-meta off ls命令显示中文，将alias命令添加到配置文件/etc/profile中 12alias ls='ls --show-control-chars --color=auto'alias gitk='gitk --all' #设置别名 解决gitk和Git Gui乱码，在/etc/gitconfig中添加或修改以下配置 12[gui] encoding = utf-8 在/etc/git-completion.bash末尾位置添加cd /d，可以让msysGit打开定位到D盘 windows平台下的msysGit工具gitk显示所有的分支 1gitk --all 显示某天以来的所有提交 1gitk --since="[YYYY-MM-dd]|[2 days ago][2 weeks ago]..." gui1git gui]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>开发配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ Idea 快捷键映射]]></title>
    <url>%2F2016%2FIntelliJ-Idea-%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[迁移IntelliJ Idea快捷键说明，此快捷键映射是在IntelliJ Idea的default快捷键的基础上进行了大量修改，部分快捷键兼容了Eclipse，修改的后的快捷键参考此文件 快捷键列表说明 Editing Search/Replace Usage Search Compile and Run Debugging Navigation Refactoring Live Templates General Reference Editing Ctrl + Space 替换为：Ctrl + ; Basic code completion (the name of any class, method or variable) 自动补全代码，可用于类、方法、变量 Ctrl + Shift + Space 替换为：Ctrl + Shift + ; Smart code completion (filters the list of methods and variables by expected type) 自动补全代码，或者列举出相应方法和变量集合 Ctrl + Shift + Enter Complete statement 补全当前行，如：在行末尾加;完成代码；if/else代码中加上{}完成代码块 Ctrl + P Parameter info (within method call arguments) 显示方法的参数 Ctrl + Q 替换为：Alt + Q Quick documentation lookup 显示注释文档 Shift + F1 External Doc 在浏览器中打开光标所在的类或者方法文档 Ctrl + mouse over code Brief Info 显示类、方法、变量概要信息 Ctrl + F1 Show descriptions of error or warning at caret 显示错误或者警告信息 Alt + Insert Generate code… (Getters, Setters, Constructors, hashCode/equals, toString) 生成代码，如：getter/setter/构造方法/… Ctrl + O Override methods 弹出窗口选择要Override/Implement的方法 Ctrl + I Implement methods 弹出窗口选择要Implement的方法 Ctrl + Alt + T Surround with… (if..else, try..catch, for, synchronized, etc.) 选择代码块，添加到if/try/for/…代码块中去 Ctrl + / Comment/uncomment with line comment 注释/取消注释代码行：//… Ctrl + Shift + / Comment/uncomment with block comment 注释/取消注释代码块：/…/ Ctrl + W Select successively increasing code blocks 选择连续增加的代码块（连续操作） Ctrl + Shift + W Decrease current selection to previous state Ctrl + W的相反操作，减少选择的代码块（连续操作） Alt + Q 替换为：Ctrl + Alt + Q Context info 显示上下文信息，如方法/类声明，光标和声明处必须不在同一屏幕处，否则不会提示 Alt + Enter Show intention actions and quick-fixes 显示意图采取行动和快速修复错误，可以自动导入包 Ctrl + Alt + L Reformat code 格式化代码 Ctrl + Alt + O Optimize imports 优化导入的类和包 Ctrl + Alt + I Auto-indent line(s) 自动缩进行 Tab / Shift + Tab Indent/unindent selected lines 缩进/取消缩进行 Ctrl + X or Shift + Delete Cut current line or selected block to clipboard 删除当前行或者选择的代码块，并复制到剪切板 Ctrl + C or Ctrl + Insert Copy current line or selected block to clipboard 复制当前行或者选择的代码块，并复制到剪切板 Ctrl + V or Shift + Insert Paste from clipboard 从剪切板粘帖 Ctrl + Shift + V Paste from recent buffers… 弹出窗口列举出最近使用的剪贴板内容，选择性插入 Ctrl + D 替换为：Alt + D Duplicate current line or selected block 复制当前行到下一行（未选择行时）；复制选择的代码块到选择的末尾位置 Ctrl + Alt + Up/Down Copy/Duplicate lines Ex 复制当前行或者选择的行到上一行或者下一行（使用Eclipse Actions插件实现Eclipse同样的复制效果） Ctrl + Y 添加：Ctrl + D Delete line at caret 删除当前行或者选择的行 Ctrl + Shift + J Smart line join 合并选择的行为一行 Ctrl + Enter Smart line split 拆分行 Shift + Enter Start new line 向下插入新行 Ctrl + Shift + U Toggle case for word at caret or selected block 大小写转换 Ctrl + Shift + ] / [ Select till code block end/start 从光标处选择代码块到结束处/开始处 Ctrl + Delete Delete to word end 从光标处删除到单词末尾 Ctrl + Backspace Delete to word start 从光标处删除到单词的开始 Ctrl + NumPad+/- Expand/collapse code block 展开/折叠代码块 Ctrl + Shift + NumPad+ Expand all 展开所有的代码 Ctrl + Shift + NumPad- Collapse all 折叠所有的代码 Ctrl + F4 Close active editor tab 关闭活动的编辑器选项卡 Search/Replace Double Shift Search everywhere 查找源代码中的任何条目，类似于Ctrl + Shift + N Ctrl + F 只保留：Ctrl + F Find 查找文本，支持多行查找/只在代码中查找/只在注释中查找/正则表达式 F3 只保留：Ctrl + L Find next 查找下一个，Ctrl + F/R之后使用 Shift + F3 只保留：Ctrl + Shift + L Find previous 查找上一个，Ctrl + F/R之后使用 Ctrl + R Replace 查找替换文本，支持多行查找/只在代码中查找/只在注释中查找/正则表达式 Ctrl + Shift + F Find in path 在指定路径/整个项目中查找文本，支持文件过滤 Ctrl + Shift + R Replace in path 在指定路径/整个项目中查找替换文本，支持文件过滤 Ctrl + Shift + S Search structurally (Ultimate Edition only) 搜索结构，使用模板方式查找 Ctrl + Shift + M Replace structurally (Ultimate Edition only) 搜索替换结构，使用模板方式查找替换 Usage Search Alt + F7 / Ctrl + F7 Find usages / Find usages in file 查找类/方法/变量使用情况。Ctrl + F7只找当前文件 Ctrl + Shift + F7 Highlight usages in file 查找类/方法/变量使用情况，只找当前文件。类似于Ctrl + F效果 Ctrl + Alt + F7 Show usages 弹出列表窗口，显示出指定的类/方法被使用情况 Compile and Run Ctrl + F9 Make project (compile modifed and dependent) 编译项目 Ctrl + Shift + F9 Compile selected file, package or module 编译选中的文件/包/模块 Alt + Shift + F10 Select configuration and run 选择指定配置/文件运行 Alt + Shift + F9 Select configuration and debug 选择指定配置/文件调试 Shift + F10 替换为：Shift + F9 Run 运行 Shift + F9 替换为：F9 Debug 调试 Ctrl + Shift + F10 Run context configuration from editor 从编辑器中的上下文配置运行，如：jUnit的test方法，ant中… Debugging F8 替换为：F6 Step over 逐行执行 F7 替换为：F5 Step into 进入方法内部 Alt + Shift + F7 Force step into 强制进入方法内部 Shift + F7 Smart step into 智能进入方法内部 Shift + F8 替换为：F7 Step out 跳出方法 Alt + F9 Run to cursor 运行到光标处所在的行 Alt + F8 Evaluate expression 弹出窗口，输入验证表达式 F9 替换为：F8 Resume program 跳到下一个断点，或者恢复运行（最后一个断点情况下） Ctrl + F8 Toggle breakpoint 当前行添加/删除断点 Ctrl + Shift + F8 View breakpoints 查看所有断点信息 Ctrl + Alt + R Reload Changed Classes 重新加载更改过代码的class（用于调试时，更改代码后不重启环境生效，不一定会起作用，如：涉及静态的） Navigation Ctrl + N Go to class 查找类 Ctrl + Shift + N Go to file 查找文件 Ctrl + Alt + Shift + N Go to symbol 查找方法 Alt + Right/Left 替换为：Ctrl + Alt + Left/Right Go to next/previous editor tab 切换到右边/左边的编辑窗口 F12 Go back to previous tool window 切换到最近使用的工具栏窗口 Esc Go to editor (from tool window) 在工具栏窗口切换到编辑窗口 Shift + Esc Hide active or last active window 隐藏当前（或最后活动的）工具窗口，并切换到编辑窗口 Ctrl + Shift + F4 Close active run/messages/find/… tab 关闭活动选项卡 Ctrl + G Go to line 定位到指定行号 Ctrl + E Recent files popup 弹出窗口列举出最近访问的文件 Ctrl + Alt + Left/Right 替换为：Alt + Right/Left Navigate back/forward 导航向前/后退 Ctrl + Shift + Backspace 替换为：Ctrl + Q Navigate to last edit location 导航到最近编辑的位置（可以连续操作） Alt + F1 Select current file or symbol in any view 定位文件/方法的位置在指定的视图下，如：项目结构/包目录/方法集合/磁盘位置等 Ctrl + B or Ctrl + Click Go to declaration 跳转到类/方法/变量定义处 Ctrl + Alt + B 添加：Ctrl + T Go to implementation(s) 跳转到实现 Ctrl + Shift + I Open quick definition lookup 显示光标处类/方法/变量的定义信息 Ctrl + Shift + B 增加：F3 Go to type declaration 跳转到类型的定义处 Ctrl + U Go to super-method/super-class 跳转到父方法/父类 Alt + Up/Down Go to previous/next method 跳转上一个/下一个方法 Ctrl + ] / [ Move to code block end/start 移动到代码块结束处/开始处，并高亮{} Ctrl + F12 File structure popup 显示当前文件的结构，可以进行方法快速过滤定位 Ctrl + H Type hierarchy 显示类结构图（类的继承层次） Ctrl + Shift + H Method hierarchy 显示方法结构图（方法的继承层次） Ctrl + Alt + H Call hierarchy 显示方法被调用结构图 F2 / Shift + F2 Next/previous highlighted error 定位到上一个/下一个错误或警告，并高亮 F4 / Ctrl + Enter Edit source / View source 在视图窗口中选择文件/方法等，快速跳转到编辑窗口中 Alt + Home Show navigation bar 光标定位到导航拦 F11 Toggle bookmark 添加/删除标签（当前行） Ctrl + F11 Toggle bookmark with mnemonic 以指定数字或者字母做为添加书签；删除书签 Ctrl + #[0-9] Go to numbered bookmark 跳转到指定标记的书签，配合Ctrl + F11使用 Shift + F11 Show bookmarks 显示所有的标签 Refactoring F5 替换为：Shift + F10 Copy 复制当前类或者文件 F6 替换为：F10 Move 移动类/方法/文件 Alt + Delete Safe Delete 安全方式删除 Shift + F6 替换为：Ctrl + Shift + R Rename 重命名方法/类/文件 Ctrl + F6 快捷键已取消 Change Signature 更改签名 Ctrl + Alt + N Inline 将方法/类重构为内联方法/匿名类 Ctrl + Alt + M Extract Method 提取选中的代码块生成一个新的方法 Ctrl + Alt + V Extract Variable 提取选中的代码块生成一个新的变量 Ctrl + Alt + F Extract Field 提取选中的代码块生成一个新的属性 Ctrl + Alt + C Extract Constant 提取选中的代码块生成一个新的常量 Ctrl + Alt + P Extract Parameter 提取选中的代码块生成一个新的参数 Live Templates Ctrl + Alt + J Surround with Live Template 选择代码块，添加到模板代码块中去 Ctrl + J Insert Live Template 插入模板代码 iter Iteration according to Java SDK 1.5 style inst Check object type with instanceof and downcast it itco Iterate elements of java.util.Collection itit Iterate elements of java.util.Iterator itli Iterate elements of java.util.List psf public static final thr throw new General Alt + #[0-9] Open corresponding tool window 打开相应的工具窗口 Ctrl + S Save all 保存所有的文件 Ctrl + Alt + Y Synchronize 同步文件到磁盘 Ctrl + Shift + F12 Toggle maximizing editor 切换最大化编辑器 Alt + Shift + F Add to Favorites 添加到收藏夹 Alt + Shift + I Inspect current file with current profile 检查当前文件与当前的配置文件 Ctrl + BackQuote (`) Quick switch current scheme 快速切换配置信息，如：皮肤/快捷键/格式化代码风格等 Ctrl + Alt + S Open Settings dialog 打开设置对话框 Ctrl + Alt + Shift + S Open Project Structure dialog 打开项目结构设置对话框 Ctrl + Shift + A Find Action 查找菜单功能/快捷键设置/配置等信息 Ctrl + Tab Switch between tabs and tool window 标签和工具窗口之间切换，选择完成之前需要先按住Ctrl键不放，Up/Down/[0-9]/[a-z]选择相应的编号 Reference Win Keymap Win Keymap Mac OS Keymap Mac OS Keymap]]></content>
      <categories>
        <category>IntelliJ Idea</category>
      </categories>
      <tags>
        <tag>开发配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows系统通过git提供的命令行查找文件内容]]></title>
    <url>%2F2016%2FWindows-File-Contentet-Search%2F</url>
    <content type="text"><![CDATA[如果还未安装，请先下载Git客户端，安装方法请百度1http://git-scm.com/download 在需要查找文件的目录，右键点击Git Bash Here1234$ find . -name &quot;*.*&quot; | xargs grep &quot; 40px;&quot;grep: .: Is a directory./css/_common/components/pagination.styl: margin: 120px 0 40px;./css/_common/components/post/post-expand.styl: padding-top: 40px; 如果是git管理的文件1git grep "工作区文件内容搜索"]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>文件内容查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2016%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
